/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.opengl3.arb;

private
{
    import derelict.opengl3.types;
    import derelict.opengl3.constants;
    import derelict.opengl3.internal;
}

// Part of ARB_sync
enum ulong GL_TIMEOUT_IGNORED  = 0xFFFFFFFFFFFFFFFF;

enum : uint
{
    // ARB_depth_buffer_float
    GL_DEPTH_COMPONENT32F             = 0x8CAC,
    GL_DEPTH32F_STENCIL8              = 0x8CAD,
    GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD,

    // ARB_framebuffer_object
    GL_INVALID_FRAMEBUFFER_OPERATION  = 0x0506,
    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210,
    GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211,
    GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212,
    GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213,
    GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214,
    GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215,
    GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216,
    GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217,
    GL_FRAMEBUFFER_DEFAULT            = 0x8218,
    GL_FRAMEBUFFER_UNDEFINED          = 0x8219,
    GL_DEPTH_STENCIL_ATTACHMENT       = 0x821A,
    GL_MAX_RENDERBUFFER_SIZE          = 0x84E8,
    GL_DEPTH_STENCIL                  = 0x84F9,
    GL_UNSIGNED_INT_24_8              = 0x84FA,
    GL_DEPTH24_STENCIL8               = 0x88F0,
    GL_TEXTURE_STENCIL_SIZE           = 0x88F1,
    GL_TEXTURE_RED_TYPE               = 0x8C10,
    GL_TEXTURE_GREEN_TYPE             = 0x8C11,
    GL_TEXTURE_BLUE_TYPE              = 0x8C12,
    GL_TEXTURE_ALPHA_TYPE             = 0x8C13,
    GL_TEXTURE_DEPTH_TYPE             = 0x8C16,
    GL_UNSIGNED_NORMALIZED            = 0x8C17,
    GL_FRAMEBUFFER_BINDING            = 0x8CA6,
    GL_DRAW_FRAMEBUFFER_BINDING       = GL_FRAMEBUFFER_BINDING,
    GL_RENDERBUFFER_BINDING           = 0x8CA7,
    GL_READ_FRAMEBUFFER               = 0x8CA8,
    GL_DRAW_FRAMEBUFFER               = 0x8CA9,
    GL_READ_FRAMEBUFFER_BINDING       = 0x8CAA,
    GL_RENDERBUFFER_SAMPLES           = 0x8CAB,
    GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0,
    GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1,
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2,
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3,
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4,
    GL_FRAMEBUFFER_COMPLETE           = 0x8CD5,
    GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6,
    GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7,
    GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB,
    GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC,
    GL_FRAMEBUFFER_UNSUPPORTED        = 0x8CDD,
    GL_MAX_COLOR_ATTACHMENTS          = 0x8CDF,
    GL_COLOR_ATTACHMENT0              = 0x8CE0,
    GL_COLOR_ATTACHMENT1              = 0x8CE1,
    GL_COLOR_ATTACHMENT2              = 0x8CE2,
    GL_COLOR_ATTACHMENT3              = 0x8CE3,
    GL_COLOR_ATTACHMENT4              = 0x8CE4,
    GL_COLOR_ATTACHMENT5              = 0x8CE5,
    GL_COLOR_ATTACHMENT6              = 0x8CE6,
    GL_COLOR_ATTACHMENT7              = 0x8CE7,
    GL_COLOR_ATTACHMENT8              = 0x8CE8,
    GL_COLOR_ATTACHMENT9              = 0x8CE9,
    GL_COLOR_ATTACHMENT10             = 0x8CEA,
    GL_COLOR_ATTACHMENT11             = 0x8CEB,
    GL_COLOR_ATTACHMENT12             = 0x8CEC,
    GL_COLOR_ATTACHMENT13             = 0x8CED,
    GL_COLOR_ATTACHMENT14             = 0x8CEE,
    GL_COLOR_ATTACHMENT15             = 0x8CEF,
    GL_DEPTH_ATTACHMENT               = 0x8D00,
    GL_STENCIL_ATTACHMENT             = 0x8D20,
    GL_FRAMEBUFFER                    = 0x8D40,
    GL_RENDERBUFFER                   = 0x8D41,
    GL_RENDERBUFFER_WIDTH             = 0x8D42,
    GL_RENDERBUFFER_HEIGHT            = 0x8D43,
    GL_RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44,
    GL_STENCIL_INDEX1                 = 0x8D46,
    GL_STENCIL_INDEX4                 = 0x8D47,
    GL_STENCIL_INDEX8                 = 0x8D48,
    GL_STENCIL_INDEX16                = 0x8D49,
    GL_RENDERBUFFER_RED_SIZE          = 0x8D50,
    GL_RENDERBUFFER_GREEN_SIZE        = 0x8D51,
    GL_RENDERBUFFER_BLUE_SIZE         = 0x8D52,
    GL_RENDERBUFFER_ALPHA_SIZE        = 0x8D53,
    GL_RENDERBUFFER_DEPTH_SIZE        = 0x8D54,
    GL_RENDERBUFFER_STENCIL_SIZE      = 0x8D55,
    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56,
    GL_MAX_SAMPLES                    = 0x8D57,

    // ARB_framebuffer_sRGB
    GL_FRAMEBUFFER_SRGB               = 0x8DB9,

    // ARB_half_float_vertex
    GL_HALF_FLOAT                     = 0x140B,

    // ARB_map_buffer_range
    GL_MAP_READ_BIT                   = 0x0001,
    GL_MAP_WRITE_BIT                  = 0x0002,
    GL_MAP_INVALIDATE_RANGE_BIT       = 0x0004,
    GL_MAP_INVALIDATE_BUFFER_BIT      = 0x0008,
    GL_MAP_FLUSH_EXPLICIT_BIT         = 0x0010,
    GL_MAP_UNSYNCHRONIZED_BIT         = 0x0020,

    // ARB_texture_compression_rgtc
    GL_COMPRESSED_RED_RGTC1           = 0x8DBB,
    GL_COMPRESSED_SIGNED_RED_RGTC1    = 0x8DBC,
    GL_COMPRESSED_RG_RGTC2            = 0x8DBD,
    GL_COMPRESSED_SIGNED_RG_RGTC2     = 0x8DBE,

    // ARB_texture_rg
    GL_RG                             = 0x8227,
    GL_RG_INTEGER                     = 0x8228,
    GL_R8                             = 0x8229,
    GL_R16                            = 0x822A,
    GL_RG8                            = 0x822B,
    GL_RG16                           = 0x822C,
    GL_R16F                           = 0x822D,
    GL_R32F                           = 0x822E,
    GL_RG16F                          = 0x822F,
    GL_RG32F                          = 0x8230,
    GL_R8I                            = 0x8231,
    GL_R8UI                           = 0x8232,
    GL_R16I                           = 0x8233,
    GL_R16UI                          = 0x8234,
    GL_R32I                           = 0x8235,
    GL_R32UI                          = 0x8236,
    GL_RG8I                           = 0x8237,
    GL_RG8UI                          = 0x8238,
    GL_RG16I                          = 0x8239,
    GL_RG16UI                         = 0x823A,
    GL_RG32I                          = 0x823B,
    GL_RG32UI                         = 0x823C,

    // ARB_vertex_array_object
    GL_VERTEX_ARRAY_BINDING           = 0x85B5,

    // ARB_uniform_buffer_object
    GL_UNIFORM_BUFFER                 = 0x8A11,
    GL_UNIFORM_BUFFER_BINDING         = 0x8A28,
    GL_UNIFORM_BUFFER_START           = 0x8A29,
    GL_UNIFORM_BUFFER_SIZE            = 0x8A2A,
    GL_MAX_VERTEX_UNIFORM_BLOCKS      = 0x8A2B,
    GL_MAX_GEOMETRY_UNIFORM_BLOCKS    = 0x8A2C,
    GL_MAX_FRAGMENT_UNIFORM_BLOCKS    = 0x8A2D,
    GL_MAX_COMBINED_UNIFORM_BLOCKS    = 0x8A2E,
    GL_MAX_UNIFORM_BUFFER_BINDINGS    = 0x8A2F,
    GL_MAX_UNIFORM_BLOCK_SIZE         = 0x8A30,
    GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31,
    GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32,
    GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33,
    GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34,
    GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35,
    GL_ACTIVE_UNIFORM_BLOCKS          = 0x8A36,
    GL_UNIFORM_TYPE                   = 0x8A37,
    GL_UNIFORM_SIZE                   = 0x8A38,
    GL_UNIFORM_NAME_LENGTH            = 0x8A39,
    GL_UNIFORM_BLOCK_INDEX            = 0x8A3A,
    GL_UNIFORM_OFFSET                 = 0x8A3B,
    GL_UNIFORM_ARRAY_STRIDE           = 0x8A3C,
    GL_UNIFORM_MATRIX_STRIDE          = 0x8A3D,
    GL_UNIFORM_IS_ROW_MAJOR           = 0x8A3E,
    GL_UNIFORM_BLOCK_BINDING          = 0x8A3F,
    GL_UNIFORM_BLOCK_DATA_SIZE        = 0x8A40,
    GL_UNIFORM_BLOCK_NAME_LENGTH      = 0x8A41,
    GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  = 0x8A42,
    GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43,
    GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44,
    GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45,
    GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46,
    GL_INVALID_INDEX                  = 0xFFFFFFFFu,

    // ARB_copy_buffer
    GL_COPY_READ_BUFFER               = 0x8F36,
    GL_COPY_WRITE_BUFFER              = 0x8F37,

    // ARB_depth_clamp
    GL_DEPTH_CLAMP                    = 0x864F,

    // ARB_provoking_vertex
    GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C,
    GL_FIRST_VERTEX_CONVENTION        = 0x8E4D,
    GL_LAST_VERTEX_CONVENTION         = 0x8E4E,
    GL_PROVOKING_VERTEX               = 0x8E4F,

    // ARB_seamless_cube_map
    GL_TEXTURE_CUBE_MAP_SEAMLESS      = 0x884F,

    // ARB_sync
    GL_MAX_SERVER_WAIT_TIMEOUT        = 0x9111,
    GL_OBJECT_TYPE                    = 0x9112,
    GL_SYNC_CONDITION                 = 0x9113,
    GL_SYNC_STATUS                    = 0x9114,
    GL_SYNC_FLAGS                     = 0x9115,
    GL_SYNC_FENCE                     = 0x9116,
    GL_SYNC_GPU_COMMANDS_COMPLETE     = 0x9117,
    GL_UNSIGNALED                     = 0x9118,
    GL_SIGNALED                       = 0x9119,
    GL_ALREADY_SIGNALED               = 0x911A,
    GL_TIMEOUT_EXPIRED                = 0x911B,
    GL_CONDITION_SATISFIED            = 0x911C,
    GL_WAIT_FAILED                    = 0x911D,
    GL_SYNC_FLUSH_COMMANDS_BIT        = 0x00000001,

    // ARB_texture_multisample
    GL_SAMPLE_POSITION                = 0x8E50,
    GL_SAMPLE_MASK                    = 0x8E51,
    GL_SAMPLE_MASK_VALUE              = 0x8E52,
    GL_MAX_SAMPLE_MASK_WORDS          = 0x8E59,
    GL_TEXTURE_2D_MULTISAMPLE         = 0x9100,
    GL_PROXY_TEXTURE_2D_MULTISAMPLE   = 0x9101,
    GL_TEXTURE_2D_MULTISAMPLE_ARRAY   = 0x9102,
    GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103,
    GL_TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104,
    GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105,
    GL_TEXTURE_SAMPLES                = 0x9106,
    GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107,
    GL_SAMPLER_2D_MULTISAMPLE         = 0x9108,
    GL_INT_SAMPLER_2D_MULTISAMPLE     = 0x9109,
    GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A,
    GL_SAMPLER_2D_MULTISAMPLE_ARRAY   = 0x910B,
    GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C,
    GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D,
    GL_MAX_COLOR_TEXTURE_SAMPLES      = 0x910E,
    GL_MAX_DEPTH_TEXTURE_SAMPLES      = 0x910F,
    GL_MAX_INTEGER_SAMPLES            = 0x9110,

    // ARB_sample_shading
    GL_SAMPLE_SHADING_ARB             = 0x8C36,
    GL_MIN_SAMPLE_SHADING_VALUE_ARB   = 0x8C37,

    // ARB_texture_cube_map_array
    GL_TEXTURE_CUBE_MAP_ARRAY_ARB     = 0x9009,
    GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = 0x900A,
    GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x900B,
    GL_SAMPLER_CUBE_MAP_ARRAY_ARB     = 0x900C,
    GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = 0x900D,
    GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900E,
    GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900F,

    // ARB_texture_gather
    GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5E,
    GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5F,

    // ARB_shading_language_include
    GL_SHADER_INCLUDE_ARB             = 0x8DAE,
    GL_NAMED_STRING_LENGTH_ARB        = 0x8DE9,
    GL_NAMED_STRING_TYPE_ARB          = 0x8DEA,

    // ARB_texture_compression_bptc
    GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = 0x8E8C,
    GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = 0x8E8D,
    GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = 0x8E8E,
    GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = 0x8E8F,

    // ARB_blend_func_extended
    GL_SRC1_COLOR                     = 0x88F9,
    GL_ONE_MINUS_SRC1_COLOR           = 0x88FA,
    GL_ONE_MINUS_SRC1_ALPHA           = 0x88FB,
    GL_MAX_DUAL_SOURCE_DRAW_BUFFERS   = 0x88FC,

    // ARB_occlusion_query2
    GL_ANY_SAMPLES_PASSED             = 0x8C2F,

    // ARB_sampler_objects
    GL_SAMPLER_BINDING                = 0x8919,

    // ARB_texture_rgb10_a2ui
    GL_RGB10_A2UI                     = 0x906F,

    // ARB_texture_swizzle
    GL_TEXTURE_SWIZZLE_R              = 0x8E42,
    GL_TEXTURE_SWIZZLE_G              = 0x8E43,
    GL_TEXTURE_SWIZZLE_B              = 0x8E44,
    GL_TEXTURE_SWIZZLE_A              = 0x8E45,
    GL_TEXTURE_SWIZZLE_RGBA           = 0x8E46,

    // ARB_timer_query
    GL_TIME_ELAPSED                   = 0x88BF,
    GL_TIMESTAMP                      = 0x8E28,

    // ARB_vertex_type_2_10_10_10_rev
    GL_INT_2_10_10_10_REV             = 0x8D9F,

    // ARB_draw_indirect
    GL_DRAW_INDIRECT_BUFFER           = 0x8F3F,
    GL_DRAW_INDIRECT_BUFFER_BINDING   = 0x8F43,

    // ARB_gpu_shader5
    GL_GEOMETRY_SHADER_INVOCATIONS    = 0x887F,
    GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A,
    GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B,
    GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C,
    GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D,

    // ARB_gpu_shader_fp64
    GL_DOUBLE_VEC2                    = 0x8FFC,
    GL_DOUBLE_VEC3                    = 0x8FFD,
    GL_DOUBLE_VEC4                    = 0x8FFE,
    GL_DOUBLE_MAT2                    = 0x8F46,
    GL_DOUBLE_MAT3                    = 0x8F47,
    GL_DOUBLE_MAT4                    = 0x8F48,
    GL_DOUBLE_MAT2x3                  = 0x8F49,
    GL_DOUBLE_MAT2x4                  = 0x8F4A,
    GL_DOUBLE_MAT3x2                  = 0x8F4B,
    GL_DOUBLE_MAT3x4                  = 0x8F4C,
    GL_DOUBLE_MAT4x2                  = 0x8F4D,
    GL_DOUBLE_MAT4x3                  = 0x8F4E,

    // ARB_shader_subroutine
    GL_ACTIVE_SUBROUTINES             = 0x8DE5,
    GL_ACTIVE_SUBROUTINE_UNIFORMS     = 0x8DE6,
    GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47,
    GL_ACTIVE_SUBROUTINE_MAX_LENGTH   = 0x8E48,
    GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49,
    GL_MAX_SUBROUTINES                = 0x8DE7,
    GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8,
    GL_NUM_COMPATIBLE_SUBROUTINES     = 0x8E4A,
    GL_COMPATIBLE_SUBROUTINES         = 0x8E4B,

    // ARB_tessellation_shader
    GL_PATCHES                        = 0x000E,
    GL_PATCH_VERTICES                 = 0x8E72,
    GL_PATCH_DEFAULT_INNER_LEVEL      = 0x8E73,
    GL_PATCH_DEFAULT_OUTER_LEVEL      = 0x8E74,
    GL_TESS_CONTROL_OUTPUT_VERTICES   = 0x8E75,
    GL_TESS_GEN_MODE                  = 0x8E76,
    GL_TESS_GEN_SPACING               = 0x8E77,
    GL_TESS_GEN_VERTEX_ORDER          = 0x8E78,
    GL_TESS_GEN_POINT_MODE            = 0x8E79,
    GL_ISOLINES                       = 0x8E7A,
    GL_FRACTIONAL_ODD                 = 0x8E7B,
    GL_FRACTIONAL_EVEN                = 0x8E7C,
    GL_MAX_PATCH_VERTICES             = 0x8E7D,
    GL_MAX_TESS_GEN_LEVEL             = 0x8E7E,
    GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F,
    GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80,
    GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81,
    GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82,
    GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83,
    GL_MAX_TESS_PATCH_COMPONENTS      = 0x8E84,
    GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85,
    GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86,
    GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89,
    GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A,
    GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C,
    GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D,
    GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E,
    GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F,
    GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0,
    GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1,
    GL_TESS_EVALUATION_SHADER         = 0x8E87,
    GL_TESS_CONTROL_SHADER            = 0x8E88,

    // ARB_transform_feedback2
    GL_TRANSFORM_FEEDBACK             = 0x8E22,
    GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23,
    GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24,
    GL_TRANSFORM_FEEDBACK_BINDING     = 0x8E25,

    // ARB_transform_feedback3
    GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70,
    GL_MAX_VERTEX_STREAMS             = 0x8E71,

    // ARB_ES2_compatibility
    GL_FIXED                          = 0x140C,
    GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A,
    GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B,
    GL_LOW_FLOAT                      = 0x8DF0,
    GL_MEDIUM_FLOAT                   = 0x8DF1,
    GL_HIGH_FLOAT                     = 0x8DF2,
    GL_LOW_INT                        = 0x8DF3,
    GL_MEDIUM_INT                     = 0x8DF4,
    GL_HIGH_INT                       = 0x8DF5,
    GL_SHADER_COMPILER                = 0x8DFA,
    GL_NUM_SHADER_BINARY_FORMATS      = 0x8DF9,
    GL_MAX_VERTEX_UNIFORM_VECTORS     = 0x8DFB,
    GL_MAX_VARYING_VECTORS            = 0x8DFC,
    GL_MAX_FRAGMENT_UNIFORM_VECTORS   = 0x8DFD,

    // ARB_get_program_binary
    GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257,
    GL_PROGRAM_BINARY_LENGTH          = 0x8741,
    GL_NUM_PROGRAM_BINARY_FORMATS     = 0x87FE,
    GL_PROGRAM_BINARY_FORMATS         = 0x87FF,

    // ARB_separate_shader_objects
    GL_VERTEX_SHADER_BIT              = 0x00000001,
    GL_FRAGMENT_SHADER_BIT            = 0x00000002,
    GL_GEOMETRY_SHADER_BIT            = 0x00000004,
    GL_TESS_CONTROL_SHADER_BIT        = 0x00000008,
    GL_TESS_EVALUATION_SHADER_BIT     = 0x00000010,
    GL_ALL_SHADER_BITS                = 0xFFFFFFFF,
    GL_PROGRAM_SEPARABLE              = 0x8258,
    GL_ACTIVE_PROGRAM                 = 0x8259,
    GL_PROGRAM_PIPELINE_BINDING       = 0x825A,

    // ARB_viewport_array
    GL_MAX_VIEWPORTS                  = 0x825B,
    GL_VIEWPORT_SUBPIXEL_BITS         = 0x825C,
    GL_VIEWPORT_BOUNDS_RANGE          = 0x825D,
    GL_LAYER_PROVOKING_VERTEX         = 0x825E,
    GL_VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F,
    GL_UNDEFINED_VERTEX               = 0x8260,

    // ARB_cl_event
    GL_SYNC_CL_EVENT_ARB              = 0x8240,
    GL_SYNC_CL_EVENT_COMPLETE_ARB     = 0x8241,

    // ARB_debug_output
    GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB   = 0x8242,
    GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243,
    GL_DEBUG_CALLBACK_FUNCTION_ARB    = 0x8244,
    GL_DEBUG_CALLBACK_USER_PARAM_ARB  = 0x8245,
    GL_DEBUG_SOURCE_API_ARB           = 0x8246,
    GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247,
    GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248,
    GL_DEBUG_SOURCE_THIRD_PARTY_ARB   = 0x8249,
    GL_DEBUG_SOURCE_APPLICATION_ARB   = 0x824A,
    GL_DEBUG_SOURCE_OTHER_ARB         = 0x824B,
    GL_DEBUG_TYPE_ERROR_ARB           = 0x824C,
    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D,
    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E,
    GL_DEBUG_TYPE_PORTABILITY_ARB     = 0x824F,
    GL_DEBUG_TYPE_PERFORMANCE_ARB     = 0x8250,
    GL_DEBUG_TYPE_OTHER_ARB           = 0x8251,
    GL_MAX_DEBUG_MESSAGE_LENGTH_ARB   = 0x9143,
    GL_MAX_DEBUG_LOGGED_MESSAGES_ARB  = 0x9144,
    GL_DEBUG_LOGGED_MESSAGES_ARB      = 0x9145,
    GL_DEBUG_SEVERITY_HIGH_ARB        = 0x9146,
    GL_DEBUG_SEVERITY_MEDIUM_ARB      = 0x9147,
    GL_DEBUG_SEVERITY_LOW_ARB         = 0x9148,

    // ARB_robustness
    GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004,
    GL_LOSE_CONTEXT_ON_RESET_ARB      = 0x8252,
    GL_GUILTY_CONTEXT_RESET_ARB       = 0x8253,
    GL_INNOCENT_CONTEXT_RESET_ARB     = 0x8254,
    GL_UNKNOWN_CONTEXT_RESET_ARB      = 0x8255,
    GL_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256,
    GL_NO_RESET_NOTIFICATION_ARB      = 0x8261,

    // ARB_compressed_texture_pixel_storage
    GL_UNPACK_COMPRESSED_BLOCK_WIDTH  = 0x9127,
    GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128,
    GL_UNPACK_COMPRESSED_BLOCK_DEPTH  = 0x9129,
    GL_UNPACK_COMPRESSED_BLOCK_SIZE   = 0x912A,
    GL_PACK_COMPRESSED_BLOCK_WIDTH    = 0x912B,
    GL_PACK_COMPRESSED_BLOCK_HEIGHT   = 0x912C,
    GL_PACK_COMPRESSED_BLOCK_DEPTH    = 0x912D,
    GL_PACK_COMPRESSED_BLOCK_SIZE     = 0x912E,

    // ARB_internalformat_query
    GL_NUM_SAMPLE_COUNTS              = 0x9380,

    // ARB_map_buffer_alignment
    GL_MIN_MAP_BUFFER_ALIGNMENT       = 0x90BC,

    // ARB_shader_atomic_counters
    GL_ATOMIC_COUNTER_BUFFER          = 0x92C0,
    GL_ATOMIC_COUNTER_BUFFER_BINDING  = 0x92C1,
    GL_ATOMIC_COUNTER_BUFFER_START    = 0x92C2,
    GL_ATOMIC_COUNTER_BUFFER_SIZE     = 0x92C3,
    GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4,
    GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5,
    GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB,
    GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC,
    GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD,
    GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE,
    GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF,
    GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0,
    GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1,
    GL_MAX_VERTEX_ATOMIC_COUNTERS     = 0x92D2,
    GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3,
    GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4,
    GL_MAX_GEOMETRY_ATOMIC_COUNTERS   = 0x92D5,
    GL_MAX_FRAGMENT_ATOMIC_COUNTERS   = 0x92D6,
    GL_MAX_COMBINED_ATOMIC_COUNTERS   = 0x92D7,
    GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8,
    GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC,
    GL_ACTIVE_ATOMIC_COUNTER_BUFFERS  = 0x92D9,
    GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA,
    GL_UNSIGNED_INT_ATOMIC_COUNTER    = 0x92DB,

    // ARB_shader_image_load_store
    GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001,
    GL_ELEMENT_ARRAY_BARRIER_BIT      = 0x00000002,
    GL_UNIFORM_BARRIER_BIT            = 0x00000004,
    GL_TEXTURE_FETCH_BARRIER_BIT      = 0x00000008,
    GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020,
    GL_COMMAND_BARRIER_BIT            = 0x00000040,
    GL_PIXEL_BUFFER_BARRIER_BIT       = 0x00000080,
    GL_TEXTURE_UPDATE_BARRIER_BIT     = 0x00000100,
    GL_BUFFER_UPDATE_BARRIER_BIT      = 0x00000200,
    GL_FRAMEBUFFER_BARRIER_BIT        = 0x00000400,
    GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800,
    GL_ATOMIC_COUNTER_BARRIER_BIT     = 0x00001000,
    GL_ALL_BARRIER_BITS               = 0xFFFFFFFF,
    GL_MAX_IMAGE_UNITS                = 0x8F38,
    GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39,
    GL_IMAGE_BINDING_NAME             = 0x8F3A,
    GL_IMAGE_BINDING_LEVEL            = 0x8F3B,
    GL_IMAGE_BINDING_LAYERED          = 0x8F3C,
    GL_IMAGE_BINDING_LAYER            = 0x8F3D,
    GL_IMAGE_BINDING_ACCESS           = 0x8F3E,
    GL_IMAGE_1D                       = 0x904C,
    GL_IMAGE_2D                       = 0x904D,
    GL_IMAGE_3D                       = 0x904E,
    GL_IMAGE_2D_RECT                  = 0x904F,
    GL_IMAGE_CUBE                     = 0x9050,
    GL_IMAGE_BUFFER                   = 0x9051,
    GL_IMAGE_1D_ARRAY                 = 0x9052,
    GL_IMAGE_2D_ARRAY                 = 0x9053,
    GL_IMAGE_CUBE_MAP_ARRAY           = 0x9054,
    GL_IMAGE_2D_MULTISAMPLE           = 0x9055,
    GL_IMAGE_2D_MULTISAMPLE_ARRAY     = 0x9056,
    GL_INT_IMAGE_1D                   = 0x9057,
    GL_INT_IMAGE_2D                   = 0x9058,
    GL_INT_IMAGE_3D                   = 0x9059,
    GL_INT_IMAGE_2D_RECT              = 0x905A,
    GL_INT_IMAGE_CUBE                 = 0x905B,
    GL_INT_IMAGE_BUFFER               = 0x905C,
    GL_INT_IMAGE_1D_ARRAY             = 0x905D,
    GL_INT_IMAGE_2D_ARRAY             = 0x905E,
    GL_INT_IMAGE_CUBE_MAP_ARRAY       = 0x905F,
    GL_INT_IMAGE_2D_MULTISAMPLE       = 0x9060,
    GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061,
    GL_UNSIGNED_INT_IMAGE_1D          = 0x9062,
    GL_UNSIGNED_INT_IMAGE_2D          = 0x9063,
    GL_UNSIGNED_INT_IMAGE_3D          = 0x9064,
    GL_UNSIGNED_INT_IMAGE_2D_RECT     = 0x9065,
    GL_UNSIGNED_INT_IMAGE_CUBE        = 0x9066,
    GL_UNSIGNED_INT_IMAGE_BUFFER      = 0x9067,
    GL_UNSIGNED_INT_IMAGE_1D_ARRAY    = 0x9068,
    GL_UNSIGNED_INT_IMAGE_2D_ARRAY    = 0x9069,
    GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A,
    GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B,
    GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C,
    GL_MAX_IMAGE_SAMPLES              = 0x906D,
    GL_IMAGE_BINDING_FORMAT           = 0x906E,
    GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7,
    GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8,
    GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9,
    GL_MAX_VERTEX_IMAGE_UNIFORMS      = 0x90CA,
    GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB,
    GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC,
    GL_MAX_GEOMETRY_IMAGE_UNIFORMS    = 0x90CD,
    GL_MAX_FRAGMENT_IMAGE_UNIFORMS    = 0x90CE,
    GL_MAX_COMBINED_IMAGE_UNIFORMS    = 0x90CF,

    // ARB_texture_storage
    GL_TEXTURE_IMMUTABLE_FORMAT       = 0x912F,
}

private __gshared bool _ARB_depth_buffer_float;
bool ARB_depth_buffer_float() @property { return _ARB_depth_buffer_float; }

private __gshared bool _ARB_framebuffer_sRGB;
bool ARB_framebuffer_sRGB() @property { return _ARB_framebuffer_sRGB; }

private __gshared bool _ARB_half_float_vertex;
bool ARB_half_float_vertex() @property { return _ARB_half_float_vertex; }

private __gshared bool _ARB_texture_compression_rgtc;
bool ARB_texture_compression_rgtc() @property { return _ARB_texture_compression_rgtc; }

private __gshared bool _ARB_texture_rg;
bool ARB_texture_rg() @property { return _ARB_texture_rg; }

private __gshared bool _ARB_depth_clamp;
bool ARB_depth_clamp() @property { return _ARB_depth_clamp; }

private __gshared bool _ARB_fragment_coord_conventions;
bool ARB_fragment_coord_conventions() @property { return _ARB_fragment_coord_conventions; }

private __gshared bool _ARB_seamless_cube_map;
bool ARB_seamless_cube_map() @property { return _ARB_seamless_cube_map; }

private __gshared bool _ARB_vertex_array_bgra;
bool ARB_vertex_array_bgra() @property { return _ARB_vertex_array_bgra; }

private __gshared bool _ARB_texture_cube_map_array;
bool ARB_texture_cube_map_array() @property { return _ARB_texture_cube_map_array; }

private __gshared bool _ARB_texture_gather;
bool ARB_texture_gather() @property { return _ARB_texture_gather; }

private __gshared bool _ARB_texture_query_lod;
bool ARB_texture_query_lod() @property { return _ARB_texture_query_lod; }

private __gshared bool _ARB_texture_compression_bptc;
bool ARB_texture_compression_bptc() @property { return _ARB_texture_compression_bptc; }

private __gshared bool _ARB_explicit_attrib_location;
bool ARB_explicit_attrib_location() @property { return _ARB_explicit_attrib_location; }

private __gshared bool _ARB_occlusion_query2;
bool ARB_occlusion_query2() @property { return _ARB_occlusion_query2; }

private __gshared bool _ARB_shader_bit_encoding;
bool ARB_shader_bit_encoding() @property { return _ARB_shader_bit_encoding; }

private __gshared bool _ARB_texture_rgb10_a2ui;
bool ARB_texture_rgb10_a2ui() @property { return _ARB_texture_rgb10_a2ui; }

private __gshared bool _ARB_texture_swizzle;
bool ARB_texture_swizzle() @property { return _ARB_texture_swizzle; }

private __gshared bool _ARB_gpu_shader5;
bool ARB_gpu_shader5() @property { return _ARB_gpu_shader5; }

private __gshared bool _ARB_texture_buffer_object_rgb32;
bool ARB_texture_buffer_object_rgb32() @property { return _ARB_texture_buffer_object_rgb32; }

private __gshared bool _ARB_shader_precision;
bool ARB_shader_precision() @property { return _ARB_shader_precision; }

private __gshared bool _ARB_shader_stencil_export;
bool ARB_shader_stencil_export() @property { return _ARB_shader_stencil_export; }

private __gshared bool _ARB_shading_language_420pack;
bool ARB_shading_language_420pack() @property { return _ARB_shading_language_420pack; }

private __gshared bool _ARB_compressed_texture_pixel_storage;
bool ARB_compressed_texture_pixel_storage() @property { return _ARB_compressed_texture_pixel_storage; }

private __gshared bool _ARB_conservative_depth;
bool ARB_conservative_depth() @property { return _ARB_conservative_depth; }

private __gshared bool _ARB_map_buffer_alignment;
bool ARB_map_buffer_alignment() @property { return _ARB_map_buffer_alignment; }

private __gshared bool _ARB_shading_language_packing;
bool ARB_shading_language_packing() @property { return _ARB_shading_language_packing; }

// ARB_framebuffer_object
extern(System)
{
    alias nothrow GLboolean function(GLuint) da_glIsRenderbuffer;
    alias nothrow void function(GLenum, GLuint) da_glBindRenderbuffer;
    alias nothrow void function(GLsizei, const(GLuint)*) da_glDeleteRenderbuffers;
    alias nothrow void function(GLsizei, GLuint*) da_glGenRenderbuffers;
    alias nothrow void function(GLenum, GLenum, GLsizei, GLsizei) da_glRenderbufferStorage;
    alias nothrow void function(GLenum, GLenum, GLint*) da_glGetRenderbufferParameteriv;
    alias nothrow GLboolean function(GLuint) da_glIsFramebuffer;
    alias nothrow void function(GLenum, GLuint) da_glBindFramebuffer;
    alias nothrow void function(GLsizei, const(GLuint)*) da_glDeleteFramebuffers;
    alias nothrow void function(GLsizei, GLuint*) da_glGenFramebuffers;
    alias nothrow GLenum function(GLenum) da_glCheckFramebufferStatus;
    alias nothrow void function(GLenum, GLenum, GLenum, GLuint, GLint) da_glFramebufferTexture1D;
    alias nothrow void function(GLenum, GLenum, GLenum, GLuint, GLint) da_glFramebufferTexture2D;
    alias nothrow void function(GLenum, GLenum, GLenum, GLuint, GLint, GLint) da_glFramebufferTexture3D;
    alias nothrow void function(GLenum, GLenum, GLenum, GLuint) da_glFramebufferRenderbuffer;
    alias nothrow void function(GLenum, GLenum, GLenum, GLint*) da_glGetFramebufferAttachmentParameteriv;
    alias nothrow void function(GLenum) da_glGenerateMipmap;
    alias nothrow void function(GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum) da_glBlitFramebuffer;
    alias nothrow void function(GLenum, GLsizei, GLenum, GLsizei, GLsizei) da_glRenderbufferStorageMultisample;
    alias nothrow void function(GLenum, GLenum, GLuint, GLint, GLint) da_glFramebufferTextureLayer;
}

__gshared
{
    da_glIsRenderbuffer glIsRenderbuffer;
    da_glBindRenderbuffer glBindRenderbuffer;
    da_glDeleteRenderbuffers glDeleteRenderbuffers;
    da_glGenRenderbuffers glGenRenderbuffers;
    da_glRenderbufferStorage glRenderbufferStorage;
    da_glGetRenderbufferParameteriv glGetRenderbufferParameteriv;
    da_glIsFramebuffer glIsFramebuffer;
    da_glBindFramebuffer glBindFramebuffer;
    da_glDeleteFramebuffers glDeleteFramebuffers;
    da_glGenFramebuffers glGenFramebuffers;
    da_glCheckFramebufferStatus glCheckFramebufferStatus;
    da_glFramebufferTexture1D glFramebufferTexture1D;
    da_glFramebufferTexture2D glFramebufferTexture2D;
    da_glFramebufferTexture3D glFramebufferTexture3D;
    da_glFramebufferRenderbuffer glFramebufferRenderbuffer;
    da_glGetFramebufferAttachmentParameteriv glGetFramebufferAttachmentParameteriv;
    da_glGenerateMipmap glGenerateMipmap;
    da_glBlitFramebuffer glBlitFramebuffer;
    da_glRenderbufferStorageMultisample glRenderbufferStorageMultisample;
    da_glFramebufferTextureLayer glFramebufferTextureLayer;
}

private __gshared bool _ARB_framebuffer_object;
bool ARB_framebuffer_object() @property { return _ARB_framebuffer_object; }
private void load_ARB_framebuffer_object()
{
    try
    {
        bindGLFunc(cast(void**)&glIsRenderbuffer, "glIsRenderbuffer");
        bindGLFunc(cast(void**)&glBindRenderbuffer, "glBindRenderbuffer");
        bindGLFunc(cast(void**)&glDeleteRenderbuffers, "glDeleteRenderbuffers");
        bindGLFunc(cast(void**)&glGenRenderbuffers, "glGenRenderbuffers");
        bindGLFunc(cast(void**)&glRenderbufferStorage, "glRenderbufferStorage");
        bindGLFunc(cast(void**)&glGetRenderbufferParameteriv, "glGetRenderbufferParameteriv");
        bindGLFunc(cast(void**)&glIsFramebuffer, "glIsFramebuffer");
        bindGLFunc(cast(void**)&glBindFramebuffer, "glBindFramebuffer");
        bindGLFunc(cast(void**)&glDeleteFramebuffers, "glBindBufferRange");
        bindGLFunc(cast(void**)&glGenFramebuffers, "glGenFramebuffers");
        bindGLFunc(cast(void**)&glCheckFramebufferStatus, "glCheckFramebufferStatus");
        bindGLFunc(cast(void**)&glFramebufferTexture1D, "glFramebufferTexture1D");
        bindGLFunc(cast(void**)&glFramebufferTexture2D, "glFramebufferTexture2D");
        bindGLFunc(cast(void**)&glFramebufferTexture3D, "glFramebufferTexture3D");
        bindGLFunc(cast(void**)&glFramebufferRenderbuffer, "glFramebufferRenderbuffer");
        bindGLFunc(cast(void**)&glGetFramebufferAttachmentParameteriv, "glGetFramebufferAttachmentParameteriv");
        bindGLFunc(cast(void**)&glGenerateMipmap, "glGenerateMipmap");
        bindGLFunc(cast(void**)&glBlitFramebuffer, "glBlitFramebuffer");
        bindGLFunc(cast(void**)&glRenderbufferStorageMultisample, "glRenderbufferStorageMultisample");
        bindGLFunc(cast(void**)&glFramebufferTextureLayer, "glFramebufferTextureLayer");
        _ARB_framebuffer_object = true;
    }
    catch(Exception e)
    {
        _ARB_framebuffer_object = false;
    }
}

// ARB_map_buffer_range
extern(System) alias nothrow GLvoid* function(GLenum, GLintptr, GLsizeiptr, GLbitfield) da_glMapBufferRange;
extern(System) alias nothrow void function(GLenum, GLintptr, GLsizeiptr) da_glFlushMappedBufferRange;
__gshared da_glMapBufferRange glMapBufferRange;
__gshared da_glFlushMappedBufferRange glFlushMappedBufferRange;

private __gshared bool _ARB_map_buffer_range;
bool ARB_map_buffer_range() @property { return _ARB_map_buffer_range; }
private void load_ARB_map_buffer_range()
{
    try
    {
        bindGLFunc(cast(void**)&glMapBufferRange, "glMapBufferRange");
        bindGLFunc(cast(void**)&glFlushMappedBufferRange, "glFlushMappedBufferRange");
        _ARB_map_buffer_range = true;
    }
    catch(Exception e)
    {
        _ARB_map_buffer_range = false;
    }
}

// ARB_vertex_array_object
extern(System)
{
    alias nothrow void function(GLuint) da_glBindVertexArray;
    alias nothrow void function(GLsizei, const(GLuint)*) da_glDeleteVertexArrays;
    alias nothrow void function(GLsizei, GLuint*) da_glGenVertexArrays;
    alias nothrow GLboolean function(GLuint) da_glIsVertexArray;
}

__gshared
{
    da_glBindVertexArray glBindVertexArray;
    da_glDeleteVertexArrays glDeleteVertexArrays;
    da_glGenVertexArrays glGenVertexArrays;
    da_glIsVertexArray glIsVertexArray;
}

private __gshared bool _ARB_vertex_array_object;
bool ARB_vertex_array_object() @property { return _ARB_vertex_array_object; }
private void load_ARB_vertex_array_object()
{
    try
    {
        bindGLFunc(cast(void**)&glBindVertexArray, "glBindVertexArray");
        bindGLFunc(cast(void**)&glDeleteVertexArrays, "glDeleteVertexArrays");
        bindGLFunc(cast(void**)&glGenVertexArrays, "glGenVertexArrays");
        bindGLFunc(cast(void**)&glIsVertexArray, "glIsVertexArray");
        _ARB_vertex_array_object = true;
    }
    catch(Exception e)
    {
        _ARB_vertex_array_object = false;
    }
}

// ARB_uniform_buffer_object
extern(System)
{
    alias nothrow void function(GLuint, GLsizei, const(GLchar*)*, GLuint*) da_glGetUniformIndices;
    alias nothrow void function(GLuint, GLsizei, const(GLuint)*, GLenum, GLint*) da_glGetActiveUniformsiv;
    alias nothrow void function(GLuint, GLuint, GLsizei, GLsizei*, GLchar*) da_glGetActiveUniformName;
    alias nothrow GLuint function(GLuint, const(GLchar)*) da_glGetUniformBlockIndex;
    alias nothrow void function(GLuint, GLuint, GLenum, GLint*) da_glGetActiveUniformBlockiv;
    alias nothrow void function(GLuint, GLuint, GLsizei, GLsizei*, GLchar*) da_glGetActiveUniformBlockName;
    alias nothrow void function(GLuint, GLuint, GLuint) da_glUniformBlockBinding;
}

__gshared
{
    da_glGetUniformIndices glGetUniformIndices;
    da_glGetActiveUniformsiv glGetActiveUniformsiv;
    da_glGetActiveUniformName glGetActiveUniformName;
    da_glGetUniformBlockIndex glGetUniformBlockIndex;
    da_glGetActiveUniformBlockiv glGetActiveUniformBlockiv;
    da_glGetActiveUniformBlockName glGetActiveUniformBlockName;
    da_glUniformBlockBinding glUniformBlockBinding;
}

private __gshared bool _ARB_uniform_buffer_object;
bool ARB_uniform_buffer_object() @property { return _ARB_uniform_buffer_object; }
private void load_ARB_uniform_buffer_object()
{
    try
    {
        bindGLFunc(cast(void**)&glGetUniformIndices, "glGetUniformIndices");
        bindGLFunc(cast(void**)&glGetActiveUniformsiv, "glGetActiveUniformsiv");
        bindGLFunc(cast(void**)&glGetActiveUniformName, "glGetActiveUniformName");
        bindGLFunc(cast(void**)&glGetUniformBlockIndex, "glGetUniformBlockIndex");
        bindGLFunc(cast(void**)&glGetActiveUniformBlockiv, "glGetActiveUniformBlockiv");
        bindGLFunc(cast(void**)&glGetActiveUniformBlockName, "glGetActiveUniformBlockName");
        bindGLFunc(cast(void**)&glUniformBlockBinding, "glUniformBlockBinding");
        _ARB_uniform_buffer_object = true;
    }
    catch(Exception e)
    {
        _ARB_uniform_buffer_object = false;
    }
}

// ARB_copy_buffer
extern(System) alias nothrow void function(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr) da_glCopyBufferSubData;
__gshared da_glCopyBufferSubData glCopyBufferSubData;

private __gshared bool _ARB_copy_buffer;
bool ARB_copy_buffer() @property { return _ARB_copy_buffer; }
private void load_ARB_copy_buffer()
{
    try
    {
        bindGLFunc(cast(void**)&glCopyBufferSubData, "glCopyBufferSubData");
        _ARB_copy_buffer = true;
    }
    catch(Exception e)
    {
        _ARB_copy_buffer = false;
    }
}

// ARB_draw_elements_base_vertex
extern(System)
{
    alias nothrow void function(GLenum, GLsizei, GLenum, const(GLvoid)*, GLint) da_glDrawElementsBaseVertex;
    alias nothrow void function(GLenum, GLuint, GLuint, GLsizei, GLenum, const(GLvoid)*, GLint) da_glDrawRangeElementsBaseVertex;
    alias nothrow void function(GLenum, GLsizei, GLenum, const(GLvoid)*, GLsizei, GLint) da_glDrawElementsInstancedBaseVertex;
    alias nothrow void function(GLenum, const(GLsizei)*, GLenum, const(GLvoid*)*, GLsizei, const(GLint)*) da_glMultiDrawElementsBaseVertex;
}

__gshared
{
    da_glDrawElementsBaseVertex glDrawElementsBaseVertex;
    da_glDrawRangeElementsBaseVertex glDrawRangeElementsBaseVertex;
    da_glDrawElementsInstancedBaseVertex glDrawElementsInstancedBaseVertex;
    da_glMultiDrawElementsBaseVertex glMultiDrawElementsBaseVertex;
}

private __gshared bool _ARB_draw_elements_base_vertex;
bool ARB_draw_elements_base_vertex() @property { return _ARB_draw_elements_base_vertex; }
private void load_ARB_draw_elements_base_vertex()
{
    try
    {
        bindGLFunc(cast(void**)&glDrawElementsBaseVertex, "glDrawElementsBaseVertex");
        bindGLFunc(cast(void**)&glDrawRangeElementsBaseVertex, "glDrawRangeElementsBaseVertex");
        bindGLFunc(cast(void**)&glDrawElementsInstancedBaseVertex, "glDrawElementsInstancedBaseVertex");
        bindGLFunc(cast(void**)&glMultiDrawElementsBaseVertex, "glMultiDrawElementsBaseVertex");
        _ARB_draw_elements_base_vertex = true;
    }
    catch(Exception e)
    {
        _ARB_draw_elements_base_vertex = false;
    }
}

// ARB_provoking_vertex
extern(System) alias nothrow void function(GLenum) da_glProvokingVertex;
__gshared da_glProvokingVertex glProvokingVertex;

private __gshared bool _ARB_provoking_vertex;
bool ARB_provoking_vertex() @property { return _ARB_provoking_vertex; }
private void load_ARB_provoking_vertex()
{
    try
    {
        bindGLFunc(cast(void**)&glProvokingVertex, "glProvokingVertex");
        _ARB_provoking_vertex = true;
    }
    catch(Exception e)
    {
        _ARB_provoking_vertex = false;
    }
}

// ARB_sync
extern(System)
{
    alias nothrow GLsync function(GLenum, GLbitfield) da_glFenceSync;
    alias nothrow GLboolean function(GLsync) da_glIsSync;
    alias nothrow void function(GLsync) da_glDeleteSync;
    alias nothrow GLenum function(GLsync, GLbitfield, GLuint64) da_glClientWaitSync;
    alias nothrow void function(GLsync, GLbitfield, GLuint64) da_glWaitSync;
    alias nothrow void function(GLsync, GLint64*) da_glGetInteger64v;
    alias nothrow void function(GLsync, GLenum, GLsizei, GLsizei*, GLint*) da_glGetSynciv;
}

__gshared
{
    da_glFenceSync glFenceSync;
    da_glIsSync glIsSync;
    da_glDeleteSync glDeleteSync;
    da_glClientWaitSync glClientWaitSync;
    da_glWaitSync glWaitSync;
    da_glGetInteger64v glGetInteger64v;
    da_glGetSynciv glGetSynciv;
}

private __gshared bool _ARB_sync;
bool ARB_sync() @property { return _ARB_sync; }
private void load_ARB_sync()
{
    try
    {
        bindGLFunc(cast(void**)&glFenceSync, "glFenceSync");
        bindGLFunc(cast(void**)&glIsSync, "glIsSync");
        bindGLFunc(cast(void**)&glDeleteSync, "glDeleteSync");
        bindGLFunc(cast(void**)&glClientWaitSync, "glClientWaitSync");
        bindGLFunc(cast(void**)&glWaitSync, "glWaitSync");
        bindGLFunc(cast(void**)&glGetInteger64v, "glGetInteger64v");
        bindGLFunc(cast(void**)&glGetSynciv, "glGetSynciv");
        _ARB_sync = true;
    }
    catch(Exception e)
    {
        _ARB_sync = false;
    }
}

// ARB_texture_multisample
extern(System)
{
    alias nothrow void function(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLboolean) da_glTexImage2DMultisample;
    alias nothrow void function(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLsizei, GLboolean) da_glTexImage3DMultisample;
    alias nothrow void function(GLenum, GLuint, GLfloat*) da_glGetMultisamplefv;
    alias nothrow void function(GLuint, GLbitfield) da_glSampleMaski;
}

__gshared
{
    da_glTexImage2DMultisample glTexImage2DMultisample;
    da_glTexImage3DMultisample glTexImage3DMultisample;
    da_glGetMultisamplefv glGetMultisamplefv;
    da_glSampleMaski glSampleMaski;
}

private __gshared bool _ARB_texture_multisample;
bool ARB_texture_multisample() @property { return _ARB_texture_multisample; }
private void load_ARB_texture_multisample()
{
    try
    {
        bindGLFunc(cast(void**)&glTexImage2DMultisample, "glTexImage2DMultisample");
        bindGLFunc(cast(void**)&glTexImage3DMultisample, "glTexImage3DMultisample");
        bindGLFunc(cast(void**)&glGetMultisamplefv, "glGetMultisamplefv");
        bindGLFunc(cast(void**)&glSampleMaski, "glSampleMaski");
        _ARB_texture_multisample = true;
    }
    catch(Exception e)
    {
        _ARB_texture_multisample = false;
    }
}

// ARB_draw_buffers_blend
extern(System)
{
    alias nothrow void function(GLuint, GLenum) da_glBlendEquationiARB;
    alias nothrow void function(GLuint, GLenum, GLenum) da_glBlendEquationSeparateiARB;
    alias nothrow void function(GLuint, GLenum, GLenum) da_glBlendFunciARB;
    alias nothrow void function(GLuint, GLenum, GLenum, GLenum, GLenum) da_glBlendFuncSeparateiARB;
}

__gshared
{
    da_glBlendEquationiARB glBlendEquationiARB;
    da_glBlendEquationSeparateiARB glBlendEquationSeparateiARB;
    da_glBlendFunciARB glBlendFunciARB;
    da_glBlendFuncSeparateiARB glBlendFuncSeparateiARB;
}

private __gshared bool _ARB_draw_buffers_blend;
bool ARB_draw_buffers_blend() @property { return _ARB_draw_buffers_blend; }
private void load_ARB_draw_buffers_blend()
{
    try
    {
        bindGLFunc(cast(void**)&glBlendEquationiARB, "glBlendEquationiARB");
        bindGLFunc(cast(void**)&glBlendEquationSeparateiARB, "glBlendEquationSeparateiARB");
        bindGLFunc(cast(void**)&glBlendFunciARB, "glBlendFunciARB");
        bindGLFunc(cast(void**)&glBlendFuncSeparateiARB, "glBlendFuncSeparateiARB");
        _ARB_draw_buffers_blend = true;
    }
    catch(Exception e)
    {
        _ARB_draw_buffers_blend = false;
    }
}

// ARB_sample_shading
extern(System) alias nothrow void function(GLclampf) da_glMinSampleShadingARB;
__gshared da_glMinSampleShadingARB glMinSampleShadingARB;

private __gshared bool _ARB_sample_shading;
bool ARB_sample_shading() @property { return _ARB_sample_shading; }
private void load_ARB_sample_shading()
{
    try
    {
        bindGLFunc(cast(void**)&glMinSampleShadingARB, "glMinSampleShadingARB");
        _ARB_sample_shading = true;
    }
    catch(Exception e)
    {
        _ARB_sample_shading = false;
    }
}

// ARB_shading_language_include
extern(System)
{
    alias nothrow void function(GLenum, GLint, const(GLchar)*, GLint, const(GLchar)*) da_glNamedStringARB;
    alias nothrow void function(GLint, const(GLchar)*) da_glDeleteNamedStringARB;
    alias nothrow void function(GLuint, GLsizei, const(GLchar)*, const(GLint)*) da_glCompileShaderIncludeARB;
    alias nothrow GLboolean function(GLint, const(GLchar)*) da_glIsNamedStringARB;
    alias nothrow void function(GLint, const(GLchar)*, GLsizei, GLint*, GLchar*) da_glGetNamedStringARB;
    alias nothrow void function(GLint, const(GLchar)*, GLenum, GLint*) da_glGetNamedStringivARB;
}

__gshared
{
    da_glNamedStringARB glNamedStringARB;
    da_glDeleteNamedStringARB glDeleteNamedStringARB;
    da_glCompileShaderIncludeARB glCompileShaderIncludeARB;
    da_glIsNamedStringARB glIsNamedStringARB;
    da_glGetNamedStringARB glGetNamedStringARB;
    da_glGetNamedStringivARB glGetNamedStringivARB;
}

private __gshared bool _ARB_shading_language_include;
bool ARB_shading_language_include() @property { return _ARB_shading_language_include; }
private void load_ARB_shading_language_include()
{
    try
    {
        bindGLFunc(cast(void**)&glNamedStringARB, "glNamedStringARB");
        bindGLFunc(cast(void**)&glDeleteNamedStringARB, "glDeleteNamedStringARB");
        bindGLFunc(cast(void**)&glCompileShaderIncludeARB, "glCompileShaderIncludeARB");
        bindGLFunc(cast(void**)&glIsNamedStringARB, "glIsNamedStringARB");
        bindGLFunc(cast(void**)&glGetNamedStringARB, "glGetNamedStringARB");
        bindGLFunc(cast(void**)&glGetNamedStringivARB, "glGetNamedStringivARB");
        _ARB_shading_language_include = true;
    }
    catch(Exception e)
    {
        _ARB_shading_language_include = false;
    }
}

// ARB_blend_func_extended
extern(System) alias nothrow void function(GLuint, GLuint, GLuint, const(GLchar)*) da_glBindFragDataLocationIndexed;
extern(System) alias nothrow GLint function(GLuint, const(GLchar)*) da_glGetFragDataIndex;
__gshared da_glBindFragDataLocationIndexed glBindFragDataLocationIndexed;
__gshared da_glGetFragDataIndex glGetFragDataIndex;

private __gshared bool _ARB_blend_func_extended;
bool ARB_blend_func_extended() @property { return _ARB_blend_func_extended; }
private void load_ARB_blend_func_extended()
{
    try
    {
        bindGLFunc(cast(void**)&glBindFragDataLocationIndexed, "glBindFragDataLocationIndexed");
        bindGLFunc(cast(void**)&glGetFragDataIndex, "glGetFragDataIndex");
        _ARB_blend_func_extended = true;
    }
    catch(Exception e)
    {
        _ARB_blend_func_extended = false;
    }
}

// ARB_sampler_objects
extern(System)
{
    alias nothrow void function(GLsizei, GLuint*) da_glGenSamplers;
    alias nothrow void function(GLsizei, const(GLuint)*) da_glDeleteSamplers;
    alias nothrow GLboolean function(GLuint) da_glIsSampler;
    alias nothrow void function(GLuint, GLuint) da_glBindSampler;
    alias nothrow void function(GLuint, GLenum, GLint) da_glSamplerParameteri;
    alias nothrow void function(GLuint, GLenum, const(GLint)*) da_glSamplerParameteriv;
    alias nothrow void function(GLuint, GLenum, GLfloat) da_glSamplerParameterf;
    alias nothrow void function(GLuint, GLenum, const(GLfloat)*) da_glSamplerParameterfv;
    alias nothrow void function(GLuint, GLenum, const(GLint)*) da_glSamplerParameterIiv;
    alias nothrow void function(GLuint, GLenum, const(GLuint)*) da_glSamplerParameterIuiv;
    alias nothrow void function(GLuint, GLenum, GLint*) da_glGetSamplerParameteriv;
    alias nothrow void function(GLuint, GLenum, GLint*) da_glGetSamplerParameterIiv;
    alias nothrow void function(GLuint, GLenum, GLfloat*) da_glGetSamplerParameterfv;
    alias nothrow void function(GLuint, GLenum, GLuint*) da_glGetSamplerParameterIuiv;
}

__gshared
{
    da_glGenSamplers glGenSamplers;
    da_glDeleteSamplers glDeleteSamplers;
    da_glIsSampler glIsSampler;
    da_glBindSampler glBindSampler;
    da_glSamplerParameteri glSamplerParameteri;
    da_glSamplerParameteriv glSamplerParameteriv;
    da_glSamplerParameterf glSamplerParameterf;
    da_glSamplerParameterfv glSamplerParameterfv;
    da_glSamplerParameterIiv glSamplerParameterIiv;
    da_glSamplerParameterIuiv glSamplerParameterIuiv;
    da_glGetSamplerParameteriv glGetSamplerParameteriv;
    da_glGetSamplerParameterIiv glGetSamplerParameterIiv;
    da_glGetSamplerParameterfv glGetSamplerParameterfv;
    da_glGetSamplerParameterIuiv glGetSamplerParameterIuiv;
}

private __gshared bool _ARB_sampler_objects;
bool ARB_sampler_objects() @property { return _ARB_sampler_objects; }
private void load_ARB_sampler_objects()
{
    try
    {
        bindGLFunc(cast(void**)&glGenSamplers, "glGenSamplers");
        bindGLFunc(cast(void**)&glDeleteSamplers, "glDeleteSamplers");
        bindGLFunc(cast(void**)&glIsSampler, "glIsSampler");
        bindGLFunc(cast(void**)&glBindSampler, "glBindSampler");
        bindGLFunc(cast(void**)&glSamplerParameteri, "glSamplerParameteri");
        bindGLFunc(cast(void**)&glSamplerParameteriv, "glSamplerParameteriv");
        bindGLFunc(cast(void**)&glSamplerParameterf, "glSamplerParameterf");
        bindGLFunc(cast(void**)&glSamplerParameterfv, "glSamplerParameterfv");
        bindGLFunc(cast(void**)&glSamplerParameterIiv, "glSamplerParameterIiv");
        bindGLFunc(cast(void**)&glSamplerParameterIuiv, "glSamplerParameterIuiv");
        bindGLFunc(cast(void**)&glGetSamplerParameteriv, "glGetSamplerParameteriv");
        bindGLFunc(cast(void**)&glGetSamplerParameterIiv, "glGetSamplerParameterIiv");
        bindGLFunc(cast(void**)&glGetSamplerParameterfv, "glGetSamplerParameterfv");
        bindGLFunc(cast(void**)&glGetSamplerParameterIuiv, "glGetSamplerParameterIuiv");
        _ARB_sampler_objects = true;
    }
    catch(Exception e)
    {
        _ARB_sampler_objects = false;
    }
}

// ARB_timer_query
extern(System)
{
    alias nothrow void function(GLuint, GLenum) da_glQueryCounter;
    alias nothrow void function(GLuint, GLenum, GLint64*) da_glGetQueryObjecti64v;
    alias nothrow void function(GLuint, GLenum, GLuint64*) da_glGetQueryObjectui64v;
}

__gshared
{
    da_glQueryCounter glQueryCounter;
    da_glGetQueryObjecti64v glGetQueryObjecti64v;
    da_glGetQueryObjectui64v glGetQueryObjectui64v;
}

private __gshared bool _ARB_timer_query;
bool ARB_timer_query() @property { return _ARB_timer_query; }
void load_ARB_timer_query()
{
    try
    {
        bindGLFunc(cast(void**)&glQueryCounter, "glQueryCounter");
        bindGLFunc(cast(void**)&glGetQueryObjecti64v, "glGetQueryObjecti64v");
        bindGLFunc(cast(void**)&glGetQueryObjectui64v, "glGetQueryObjectui64v");
        _ARB_timer_query = true;
    }
    catch(Exception e)
    {
        _ARB_timer_query = false;
    }
}

// ARB_vertex_type_2_10_10_10_rev
extern(System)
{
    alias nothrow void function(GLenum, GLuint) da_glVertexP2ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glVertexP2uiv;
    alias nothrow void function(GLenum, GLuint) da_glVertexP3ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glVertexP3uiv;
    alias nothrow void function(GLenum, GLuint) da_glVertexP4ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glVertexP4uiv;
    alias nothrow void function(GLenum, GLuint) da_glTexCoordP1ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glTexCoordP1uiv;
    alias nothrow void function(GLenum, GLuint) da_glTexCoordP2ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glTexCoordP2uiv;
    alias nothrow void function(GLenum, GLuint) da_glTexCoordP3ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glTexCoordP3uiv;
    alias nothrow void function(GLenum, GLuint) da_glTexCoordP4ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glTexCoordP4uiv;
    alias nothrow void function(GLenum, GLenum, GLuint) da_glMultiTexCoordP1ui;
    alias nothrow void function(GLenum, GLenum, const(GLuint)*) da_glMultiTexCoordP1uiv;
    alias nothrow void function(GLenum, GLenum, GLuint) da_glMultiTexCoordP2ui;
    alias nothrow void function(GLenum, GLenum, const(GLuint)*) da_glMultiTexCoordP2uiv;
    alias nothrow void function(GLenum, GLenum, GLuint) da_glMultiTexCoordP3ui;
    alias nothrow void function(GLenum, GLenum, const(GLuint)*) da_glMultiTexCoordP3uiv;
    alias nothrow void function(GLenum, GLenum, GLuint) da_glMultiTexCoordP4ui;
    alias nothrow void function(GLenum, GLenum, const(GLuint)*) da_glMultiTexCoordP4uiv;
    alias nothrow void function(GLenum, GLuint) da_glNormalP3ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glNormalP3uiv;
    alias nothrow void function(GLenum, GLuint) da_glColorP3ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glColorP3uiv;
    alias nothrow void function(GLenum, GLuint) da_glColorP4ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glColorP4uiv;
    alias nothrow void function(GLenum, GLuint) da_glSecondaryColorP3ui;
    alias nothrow void function(GLenum, const(GLuint)*) da_glSecondaryColorP3uiv;
    alias nothrow void function(GLuint, GLenum, GLboolean, GLuint) da_glVertexAttribP1ui;
    alias nothrow void function(GLuint, GLenum, GLboolean, const(GLuint)*) da_glVertexAttribP1uiv;
    alias nothrow void function(GLuint, GLenum, GLboolean, GLuint) da_glVertexAttribP2ui;
    alias nothrow void function(GLuint, GLenum, GLboolean, const(GLuint)*) da_glVertexAttribP2uiv;
    alias nothrow void function(GLuint, GLenum, GLboolean, GLuint) da_glVertexAttribP3ui;
    alias nothrow void function(GLuint, GLenum, GLboolean, const(GLuint)*) da_glVertexAttribP3uiv;
    alias nothrow void function(GLuint, GLenum, GLboolean, GLuint) da_glVertexAttribP4ui;
    alias nothrow void function(GLuint, GLenum, GLboolean, const(GLuint)*) da_glVertexAttribP4uiv;
}

__gshared
{
    da_glVertexP2ui glVertexP2ui;
    da_glVertexP2uiv glVertexP2uiv;
    da_glVertexP3ui glVertexP3ui;
    da_glVertexP3uiv glVertexP3uiv;
    da_glVertexP4ui glVertexP4ui;
    da_glVertexP4uiv glVertexP4uiv;
    da_glTexCoordP1ui glTexCoordP1ui;
    da_glTexCoordP1uiv glTexCoordP1uiv;
    da_glTexCoordP2ui glTexCoordP2ui;
    da_glTexCoordP2uiv glTexCoordP2uiv;
    da_glTexCoordP3ui glTexCoordP3ui;
    da_glTexCoordP3uiv glTexCoordP3uiv;
    da_glTexCoordP4ui glTexCoordP4ui;
    da_glTexCoordP4uiv glTexCoordP4uiv;
    da_glMultiTexCoordP1ui glMultiTexCoordP1ui;
    da_glMultiTexCoordP1uiv glMultiTexCoordP1uiv;
    da_glMultiTexCoordP2ui glMultiTexCoordP2ui;
    da_glMultiTexCoordP2uiv glMultiTexCoordP2uiv;
    da_glMultiTexCoordP3ui glMultiTexCoordP3ui;
    da_glMultiTexCoordP3uiv glMultiTexCoordP3uiv;
    da_glMultiTexCoordP4ui glMultiTexCoordP4ui;
    da_glMultiTexCoordP4uiv glMultiTexCoordP4uiv;
    da_glNormalP3ui glNormalP3ui;
    da_glNormalP3uiv glNormalP3uiv;
    da_glColorP3ui glColorP3ui;
    da_glColorP3uiv glColorP3uiv;
    da_glColorP4ui glColorP4ui;
    da_glColorP4uiv glColorP4uiv;
    da_glSecondaryColorP3ui glSecondaryColorP3ui;
    da_glSecondaryColorP3uiv glSecondaryColorP3uiv;
    da_glVertexAttribP1ui glVertexAttribP1ui;
    da_glVertexAttribP1uiv glVertexAttribP1uiv;
    da_glVertexAttribP2ui glVertexAttribP2ui;
    da_glVertexAttribP2uiv glVertexAttribP2uiv;
    da_glVertexAttribP3ui glVertexAttribP3ui;
    da_glVertexAttribP3uiv glVertexAttribP3uiv;
    da_glVertexAttribP4ui glVertexAttribP4ui;
    da_glVertexAttribP4uiv glVertexAttribP4uiv;
}

private __gshared bool _ARB_vertex_type_2_10_10_10_rev;
bool ARB_vertex_type_2_10_10_10_rev() @property { return _ARB_vertex_type_2_10_10_10_rev; }
private void load_ARB_vertex_type_2_10_10_10_rev()
{
    try
    {
        bindGLFunc(cast(void**)&glVertexP2ui, "glVertexP2ui");
        bindGLFunc(cast(void**)&glVertexP2uiv, "glVertexP2uiv");
        bindGLFunc(cast(void**)&glVertexP3ui, "glVertexP3ui");
        bindGLFunc(cast(void**)&glVertexP3uiv, "glVertexP3uiv");
        bindGLFunc(cast(void**)&glVertexP4ui, "glVertexP4ui");
        bindGLFunc(cast(void**)&glVertexP4uiv, "glVertexP4uiv");
        bindGLFunc(cast(void**)&glTexCoordP1ui, "glTexCoordP1ui");
        bindGLFunc(cast(void**)&glTexCoordP1uiv, "glTexCoordP1uiv");
        bindGLFunc(cast(void**)&glTexCoordP2ui, "glTexCoordP2ui");
        bindGLFunc(cast(void**)&glTexCoordP2uiv, "glTexCoordP2uiv");
        bindGLFunc(cast(void**)&glTexCoordP3ui, "glTexCoordP3ui");
        bindGLFunc(cast(void**)&glTexCoordP3uiv, "glTexCoordP3uiv");
        bindGLFunc(cast(void**)&glTexCoordP4ui, "glTexCoordP4ui");
        bindGLFunc(cast(void**)&glTexCoordP4uiv, "glTexCoordP4uiv");
        bindGLFunc(cast(void**)&glMultiTexCoordP1ui, "glMultiTexCoordP1ui");
        bindGLFunc(cast(void**)&glMultiTexCoordP1uiv, "glMultiTexCoordP1uiv");
        bindGLFunc(cast(void**)&glMultiTexCoordP2ui, "glMultiTexCoordP2ui");
        bindGLFunc(cast(void**)&glMultiTexCoordP2uiv, "glMultiTexCoordP2uiv");
        bindGLFunc(cast(void**)&glMultiTexCoordP3ui, "glMultiTexCoordP3ui");
        bindGLFunc(cast(void**)&glMultiTexCoordP3uiv, "glMultiTexCoordP3uiv");
        bindGLFunc(cast(void**)&glMultiTexCoordP4ui, "glMultiTexCoordP4ui");
        bindGLFunc(cast(void**)&glMultiTexCoordP4uiv, "glMultiTexCoordP4uiv");
        bindGLFunc(cast(void**)&glNormalP3ui, "glNormalP3ui");
        bindGLFunc(cast(void**)&glNormalP3uiv, "glNormalP3uiv");
        bindGLFunc(cast(void**)&glColorP3ui, "glColorP3ui");
        bindGLFunc(cast(void**)&glColorP3uiv, "glColorP3uiv");
        bindGLFunc(cast(void**)&glColorP4ui, "glColorP4ui");
        bindGLFunc(cast(void**)&glColorP4uiv, "glColorP4uiv");
        bindGLFunc(cast(void**)&glSecondaryColorP3ui, "glSecondaryColorP3ui");
        bindGLFunc(cast(void**)&glSecondaryColorP3uiv, "glSecondaryColorP3uiv");
        bindGLFunc(cast(void**)&glVertexAttribP1ui, "glVertexAttribP1ui");
        bindGLFunc(cast(void**)&glVertexAttribP1uiv, "glVertexAttribP1uiv");
        bindGLFunc(cast(void**)&glVertexAttribP2ui, "glVertexAttribP2ui");
        bindGLFunc(cast(void**)&glVertexAttribP2uiv, "glVertexAttribP2uiv");
        bindGLFunc(cast(void**)&glVertexAttribP3ui, "glVertexAttribP3ui");
        bindGLFunc(cast(void**)&glVertexAttribP3uiv, "glVertexAttribP3uiv");
        bindGLFunc(cast(void**)&glVertexAttribP4ui, "glVertexAttribP4ui");
        bindGLFunc(cast(void**)&glVertexAttribP4uiv, "glVertexAttribP4uiv");
        _ARB_vertex_type_2_10_10_10_rev = true;
    }
    catch(Exception e)
    {
        _ARB_vertex_type_2_10_10_10_rev = false;
    }
}

// ARB_draw_indirect
extern(System) alias nothrow void function(GLenum, const(GLvoid)*) da_glDrawArraysIndirect;
extern(System) alias nothrow void function(GLenum, GLenum, const(GLvoid)*) da_glDrawElementsIndirect;

__gshared
{
    da_glDrawArraysIndirect glDrawArraysIndirect;
    da_glDrawElementsIndirect glDrawElementsIndirect;
}

private __gshared bool _ARB_draw_indirect;
bool ARB_draw_indirect() @property { return _ARB_draw_indirect; }
private void load_ARB_draw_indirect()
{
    try
    {
        bindGLFunc(cast(void**)&glDrawArraysIndirect, "glDrawArraysIndirect");
        bindGLFunc(cast(void**)&glDrawElementsIndirect, "glDrawElementsIndirect");
        _ARB_draw_indirect = true;
    }
    catch(Exception e)
    {
        _ARB_draw_indirect = false;
    }
}

// ARB_gpu_shader_fp64
extern(System)
{
    alias nothrow void function(GLint, GLdouble) da_glUniform1d;
    alias nothrow void function(GLint, GLdouble, GLdouble) da_glUniform2d;
    alias nothrow void function(GLint, GLdouble, GLdouble, GLdouble) da_glUniform3d;
    alias nothrow void function(GLint, GLdouble, GLdouble, GLdouble) da_glUniform4d;
    alias nothrow void function(GLint, GLsizei, const(GLdouble)*) da_glUniform1dv;
    alias nothrow void function(GLint, GLsizei, const(GLdouble)*) da_glUniform2dv;
    alias nothrow void function(GLint, GLsizei, const(GLdouble)*) da_glUniform3dv;
    alias nothrow void function(GLint, GLsizei, const(GLdouble)*) da_glUniform4dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix2dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix3dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix4dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix2x3dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix2x4dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix3x2dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix3x4dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix4x2dv;
    alias nothrow void function(GLint, GLsizei, GLboolean, const(GLdouble)*) da_glUniformMatrix4x3dv;
    alias nothrow void function(GLuint, GLint, GLdouble*) da_glGetUniformdv;
}

__gshared
{
    da_glUniform1d glUniform1d;
    da_glUniform2d glUniform2d;
    da_glUniform3d glUniform3d;
    da_glUniform4d glUniform4d;
    da_glUniform1dv glUniform1dv;
    da_glUniform2dv glUniform2dv;
    da_glUniform3dv glUniform3dv;
    da_glUniform4dv glUniform4dv;
    da_glUniformMatrix2dv glUniformMatrix2dv;
    da_glUniformMatrix3dv glUniformMatrix3dv;
    da_glUniformMatrix4dv glUniformMatrix4dv;
    da_glUniformMatrix2x3dv glUniformMatrix2x3dv;
    da_glUniformMatrix2x4dv glUniformMatrix2x4dv;
    da_glUniformMatrix3x2dv glUniformMatrix3x2dv;
    da_glUniformMatrix3x4dv glUniformMatrix3x4dv;
    da_glUniformMatrix4x2dv glUniformMatrix4x2dv;
    da_glUniformMatrix4x3dv glUniformMatrix4x3dv;
    da_glGetUniformdv glGetUniformdv;
}

private __gshared bool _ARB_gpu_shader_fp64;
bool ARB_gpu_shader_fp64() @property { return _ARB_gpu_shader_fp64; }
private void load_ARB_gpu_shader_fp64()
{
    try
    {
        bindGLFunc(cast(void**)&glUniform1d, "glUniform1d");
        bindGLFunc(cast(void**)&glUniform2d, "glUniform2d");
        bindGLFunc(cast(void**)&glUniform3d, "glUniform3d");
        bindGLFunc(cast(void**)&glUniform4d, "glUniform4d");
        bindGLFunc(cast(void**)&glUniform1dv, "glUniform1dv");
        bindGLFunc(cast(void**)&glUniform2dv, "glUniform2dv");
        bindGLFunc(cast(void**)&glUniform3dv, "glUniform3dv");
        bindGLFunc(cast(void**)&glUniform4dv, "glUniform4dv");
        bindGLFunc(cast(void**)&glUniformMatrix2dv, "glUniformMatrix2dv");
        bindGLFunc(cast(void**)&glUniformMatrix3dv, "glUniformMatrix3dv");
        bindGLFunc(cast(void**)&glUniformMatrix4dv, "glUniformMatrix4dv");
        bindGLFunc(cast(void**)&glUniformMatrix2x3dv, "glUniformMatrix2x3dv");
        bindGLFunc(cast(void**)&glUniformMatrix2x4dv, "glUniformMatrix2x4dv");
        bindGLFunc(cast(void**)&glUniformMatrix3x2dv, "glUniformMatrix3x2dv");
        bindGLFunc(cast(void**)&glUniformMatrix3x4dv, "glUniformMatrix3x4dv");
        bindGLFunc(cast(void**)&glUniformMatrix4x2dv, "glUniformMatrix4x2dv");
        bindGLFunc(cast(void**)&glUniformMatrix4x3dv, "glUniformMatrix4x3dv");
        _ARB_gpu_shader_fp64 = true;
    }
    catch(Exception e)
    {
        _ARB_gpu_shader_fp64 = false;
    }
}

// ARB_shader_subroutine
extern(System)
{
    alias nothrow GLint function(GLuint, GLenum, const(GLchar)*) da_glGetSubroutineUniformLocation;
    alias nothrow GLuint function(GLuint, GLenum, const(GLchar)*) da_glGetSubroutineIndex;
    alias nothrow void function(GLuint, GLenum, GLuint, GLenum, GLint*) da_glGetActiveSubroutineUniformiv;
    alias nothrow void function(GLuint, GLenum, GLuint, GLsizei, GLsizei*, GLchar*) da_glGetActiveSubroutineUniformName;
    alias nothrow void function(GLuint, GLenum, GLuint, GLsizei, GLsizei*, GLchar*) da_glGetActiveSubroutineName;
    alias nothrow void function(GLenum, GLsizei, const(GLuint)*) da_glUniformSubroutinesuiv;
    alias nothrow void function(GLenum, GLint, GLuint*) da_glGetUniformSubroutineuiv;
    alias nothrow void function(GLuint, GLenum, GLenum, GLint*) da_glGetProgramStageiv;
}

__gshared
{
    da_glGetSubroutineUniformLocation glGetSubroutineUniformLocation;
    da_glGetSubroutineIndex glGetSubroutineIndex;
    da_glGetActiveSubroutineUniformiv glGetActiveSubroutineUniformiv;
    da_glGetActiveSubroutineUniformName glGetActiveSubroutineUniformName;
    da_glGetActiveSubroutineName glGetActiveSubroutineName;
    da_glUniformSubroutinesuiv glUniformSubroutinesuiv;
    da_glGetUniformSubroutineuiv glGetUniformSubroutineuiv;
    da_glGetProgramStageiv glGetProgramStageiv;
}

private __gshared bool _ARB_shader_subroutine;
bool ARB_shader_subroutine() @property { return _ARB_shader_subroutine; }
private void load_ARB_shader_subroutine()
{
    try
    {
        bindGLFunc(cast(void**)&glGetSubroutineUniformLocation, "glGetSubroutineUniformLocation");
        bindGLFunc(cast(void**)&glGetSubroutineIndex, "glGetSubroutineIndex");
        bindGLFunc(cast(void**)&glGetActiveSubroutineUniformiv, "glGetActiveSubroutineUniformiv");
        bindGLFunc(cast(void**)&glGetActiveSubroutineUniformName, "glGetActiveSubroutineUniformName");
        bindGLFunc(cast(void**)&glGetActiveSubroutineName, "glGetActiveSubroutineName");
        bindGLFunc(cast(void**)&glUniformSubroutinesuiv, "glUniformSubroutinesuiv");
        bindGLFunc(cast(void**)&glGetUniformSubroutineuiv, "glGetUniformSubroutineuiv");
        bindGLFunc(cast(void**)&glGetProgramStageiv, "glGetProgramStageiv");
        _ARB_shader_subroutine = true;
    }
    catch(Exception e)
    {
        _ARB_shader_subroutine = false;
    }
}

// ARB_tessellation_shader
extern(System) alias nothrow void function(GLenum, GLint) da_glPatchParameteri;
extern(System) alias nothrow void function(GLenum, const(GLfloat)*) da_glPatchParameterfv;
__gshared da_glPatchParameteri glPatchParameteri;
__gshared da_glPatchParameterfv glPatchParameterfv;

private __gshared bool _ARB_tessellation_shader;
bool ARB_tessellation_shader() @property { return _ARB_tessellation_shader; }
private void load_ARB_tessellation_shader()
{
    try
    {
        bindGLFunc(cast(void**)&glPatchParameteri, "glPatchParameteri");
        bindGLFunc(cast(void**)&glPatchParameterfv, "glPatchParameterfv");
        _ARB_tessellation_shader = true;
    }
    catch(Exception e)
    {
        _ARB_tessellation_shader = false;
    }
}

// ARB_transform_feedback2
extern(System)
{
    alias nothrow void function(GLenum, GLuint) da_glBindTransformFeedback;
    alias nothrow void function(GLsizei, const(GLuint)*) da_glDeleteTransformFeedbacks;
    alias nothrow void function(GLsizei, GLuint*) da_glGenTransformFeedbacks;
    alias nothrow GLboolean function(GLuint) da_glIsTransformFeedback;
    alias nothrow void function() da_glPauseTransformFeedback;
    alias nothrow void function() da_glResumeTransformFeedback;
    alias nothrow void function(GLenum, GLuint) da_glDrawTransformFeedback;
}

__gshared
{
    da_glBindTransformFeedback glBindTransformFeedback;
    da_glDeleteTransformFeedbacks glDeleteTransformFeedbacks;
    da_glGenTransformFeedbacks glGenTransformFeedbacks;
    da_glIsTransformFeedback glIsTransformFeedback;
    da_glPauseTransformFeedback glPauseTransformFeedback;
    da_glResumeTransformFeedback glResumeTransformFeedback;
    da_glDrawTransformFeedback glDrawTransformFeedback;
}

private __gshared bool _ARB_transform_feedback2;
bool ARB_transform_feedback2() { return _ARB_transform_feedback2; }
void load_ARB_transform_feedback2()
{
    try
    {
        bindGLFunc(cast(void**)&glBindTransformFeedback, "glBindTransformFeedback");
        bindGLFunc(cast(void**)&glDeleteTransformFeedbacks, "glDeleteTransformFeedbacks");
        bindGLFunc(cast(void**)&glGenTransformFeedbacks, "glGenTransformFeedbacks");
        bindGLFunc(cast(void**)&glIsTransformFeedback, "glIsTransformFeedback");
        bindGLFunc(cast(void**)&glPauseTransformFeedback, "glPauseTransformFeedback");
        bindGLFunc(cast(void**)&glResumeTransformFeedback, "glResumeTransformFeedback");
        bindGLFunc(cast(void**)&glDrawTransformFeedback, "glDrawTransformFeedback");
        _ARB_transform_feedback2 = true;
    }
    catch(Exception e)
    {
        _ARB_transform_feedback2 = false;
    }
}

// ARB_transform_feedback3
extern(System)
{
    alias nothrow void function(GLenum, GLuint, GLuint) da_glDrawTransformFeedbackStream;
    alias nothrow void function(GLenum, GLuint, GLuint) da_glBeginQueryIndexed;
    alias nothrow void function(GLenum, GLuint) da_glEndQueryIndexed;
    alias nothrow void function(GLenum, GLuint, GLenum, GLint*) da_glGetQueryIndexediv;
}

__gshared
{
    da_glDrawTransformFeedbackStream glDrawTransformFeedbackStream;
    da_glBeginQueryIndexed glBeginQueryIndexed;
    da_glEndQueryIndexed glEndQueryIndexed;
    da_glGetQueryIndexediv glGetQueryIndexediv;
}

private __gshared bool _ARB_transform_feedback3;
bool ARB_transform_feedback3() { return _ARB_transform_feedback3; }
private void load_ARB_transform_feedback3()
{
    try
    {
        bindGLFunc(cast(void**)&glDrawTransformFeedbackStream, "glDrawTransformFeedbackStream");
        bindGLFunc(cast(void**)&glBeginQueryIndexed, "glBeginQueryIndexed");
        bindGLFunc(cast(void**)&glEndQueryIndexed, "glEndQueryIndexed");
        bindGLFunc(cast(void**)&glGetQueryIndexediv, "glGetQueryIndexediv");
        _ARB_transform_feedback3 = true;
    }
    catch(Exception e)
    {
        _ARB_transform_feedback3 = false;
    }
}

// ARB_ES2_compatibility
extern(System)
{
    alias nothrow void function() da_glReleaseShaderCompiler;
    alias nothrow void function(GLsizei, const(GLuint)*, GLenum, const(GLvoid)*, GLsizei) da_glShaderBinary;
    alias nothrow void function(GLenum, GLenum, GLint*, GLint*) da_glGetShaderPrecisionFormat;
    alias nothrow void function(GLclampf, GLclampf) da_glDepthRangef;
    alias nothrow void function(GLclampf) da_glClearDepthf;
}

__gshared
{
    da_glReleaseShaderCompiler glReleaseShaderCompiler;
    da_glShaderBinary glShaderBinary;
    da_glGetShaderPrecisionFormat glGetShaderPrecisionFormat;
    da_glDepthRangef glDepthRangef;
    da_glClearDepthf glClearDepthf;
}

private __gshared bool _ARB_ES2_compatibility;
bool ARB_ES2_compatibility() @property { return _ARB_ES2_compatibility; }
private void load_ARB_ES2_compatibility()
{
    try
    {
        bindGLFunc(cast(void**)&glReleaseShaderCompiler, "glReleaseShaderCompiler");
        bindGLFunc(cast(void**)&glShaderBinary, "glShaderBinary");
        bindGLFunc(cast(void**)&glGetShaderPrecisionFormat, "glGetShaderPrecisionFormat");
        bindGLFunc(cast(void**)&glDepthRangef, "glDepthRangef");
        bindGLFunc(cast(void**)&glClearDepthf, "glClearDepthf");
        _ARB_ES2_compatibility = true;
    }
    catch(Exception e)
    {
        _ARB_ES2_compatibility = false;
    }
}

// ARB_get_program_binary
extern(System)
{
    alias nothrow void function(GLuint, GLsizei, GLsizei*, GLenum*, GLvoid*) da_glGetProgramBinary;
    alias nothrow void function(GLuint, GLenum, const(GLvoid)*, GLsizei) da_glProgramBinary;
    alias nothrow void function(GLuint, GLenum, GLint) da_glProgramParameteri;
}

__gshared
{
    da_glGetProgramBinary glGetProgramBinary;
    da_glProgramBinary glProgramBinary;
    da_glProgramParameteri glProgramParameteri;
}

private __gshared bool _ARB_get_program_binary;
bool ARB_get_program_binary() @property { return _ARB_get_program_binary; }
private void load_ARB_get_program_binary()
{
    try
    {
        bindGLFunc(cast(void**)&glGetProgramBinary, "glGetProgramBinary");
        bindGLFunc(cast(void**)&glProgramBinary, "glProgramBinary");
        bindGLFunc(cast(void**)&glProgramParameteri, "glProgramParameteri");
        _ARB_get_program_binary = true;
    }
    catch(Exception e)
    {
        _ARB_get_program_binary = false;
    }
}

// ARB_separate_shader_objects
extern(System)
{
    alias nothrow void function(GLuint, GLbitfield, GLuint) da_glUseProgramStages;
    alias nothrow void function(GLuint, GLuint) da_glActiveShaderProgram;
    alias nothrow GLuint function(GLenum, GLsizei, const(GLchar*)*) da_glCreateShaderProgramv;
    alias nothrow void function(GLuint) da_glBindProgramPipeline;
    alias nothrow void function(GLsizei, const(GLuint)*) da_glDeleteProgramPipelines;
    alias nothrow void function(GLsizei, GLuint*) da_glGenProgramPipelines;
    alias nothrow GLboolean function(GLuint) da_glIsProgramPipeline;
    alias nothrow void function(GLuint, GLenum, GLint*) da_glGetProgramPipelineiv;
    alias nothrow void function(GLuint, GLint, GLint) da_glProgramUniform1i;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLint)*) da_glProgramUniform1iv;
    alias nothrow void function(GLuint, GLint, GLfloat) da_glProgramUniform1f;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLfloat)*) da_glProgramUniform1fv;
    alias nothrow void function(GLuint, GLint, GLdouble) da_glProgramUniform1d;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLdouble)*) da_glProgramUniform1dv;
    alias nothrow void function(GLuint, GLint, GLuint) da_glProgramUniform1ui;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLuint)*) da_glProgramUniform1uiv;
    alias nothrow void function(GLuint, GLint, GLint, GLint) da_glProgramUniform2i;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLint)*) da_glProgramUniform2iv;
    alias nothrow void function(GLuint, GLint, GLfloat, GLfloat) da_glProgramUniform2f;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLfloat)*) da_glProgramUniform2fv;
    alias nothrow void function(GLuint, GLint, GLdouble, GLdouble) da_glProgramUniform2d;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLdouble)*) da_glProgramUniform2dv;
    alias nothrow void function(GLuint, GLint, GLuint, GLuint) da_glProgramUniform2ui;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLuint)*) da_glProgramUniform2uiv;
    alias nothrow void function(GLuint, GLint, GLint, GLint, GLint) da_glProgramUniform3i;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLint)*) da_glProgramUniform3iv;
    alias nothrow void function(GLuint, GLint, GLfloat, GLfloat, GLfloat) da_glProgramUniform3f;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLfloat)*) da_glProgramUniform3fv;
    alias nothrow void function(GLuint, GLint, GLdouble, GLdouble, GLdouble) da_glProgramUniform3d;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLdouble)*) da_glProgramUniform3dv;
    alias nothrow void function(GLuint, GLint, GLuint, GLuint, GLuint) da_glProgramUniform3ui;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLuint)*) da_glProgramUniform3uiv;
    alias nothrow void function(GLuint, GLint, GLint, GLint, GLint, GLint) da_glProgramUniform4i;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLint)*) da_glProgramUniform4iv;
    alias nothrow void function(GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat) da_glProgramUniform4f;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLfloat)*) da_glProgramUniform4fv;
    alias nothrow void function(GLuint, GLint, GLdouble, GLdouble, GLdouble, GLdouble) da_glProgramUniform4d;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLdouble)*) da_glProgramUniform4dv;
    alias nothrow void function(GLuint, GLint, GLuint, GLuint, GLuint, GLuint) da_glProgramUniform4ui;
    alias nothrow void function(GLuint, GLint, GLsizei, const(GLuint)*) da_glProgramUniform4uiv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix2fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix3fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix4fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix2dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix3dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix4dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix2x3fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix3x2fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix2x4fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix4x2fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix3x4fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*) da_glProgramUniformMatrix4x3fv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix2x3dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix3x2dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix2x4dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix4x2dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix3x4dv;
    alias nothrow void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*) da_glProgramUniformMatrix4x3dv;
    alias nothrow void function(GLuint) da_glValidateProgramPipeline;
    alias nothrow void function(GLuint, GLsizei, GLsizei*, GLchar*) da_glGetProgramPipelineInfoLog;
}

__gshared
{
    da_glUseProgramStages glUseProgramStages;
    da_glActiveShaderProgram glActiveShaderProgram;
    da_glCreateShaderProgramv glCreateShaderProgramv;
    da_glBindProgramPipeline glBindProgramPipeline;
    da_glDeleteProgramPipelines glDeleteProgramPipelines;
    da_glGenProgramPipelines glGenProgramPipelines;
    da_glIsProgramPipeline glIsProgramPipeline;
    da_glGetProgramPipelineiv glGetProgramPipelineiv;
    da_glProgramUniform1i glProgramUniform1i;
    da_glProgramUniform1iv glProgramUniform1iv;
    da_glProgramUniform1f glProgramUniform1f;
    da_glProgramUniform1fv glProgramUniform1fv;
    da_glProgramUniform1d glProgramUniform1d;
    da_glProgramUniform1dv glProgramUniform1dv;
    da_glProgramUniform1ui glProgramUniform1ui;
    da_glProgramUniform1uiv glProgramUniform1uiv;
    da_glProgramUniform2i glProgramUniform2i;
    da_glProgramUniform2iv glProgramUniform2iv;
    da_glProgramUniform2f glProgramUniform2f;
    da_glProgramUniform2fv glProgramUniform2fv;
    da_glProgramUniform2d glProgramUniform2d;
    da_glProgramUniform2dv glProgramUniform2dv;
    da_glProgramUniform2ui glProgramUniform2ui;
    da_glProgramUniform2uiv glProgramUniform2uiv;
    da_glProgramUniform3i glProgramUniform3i;
    da_glProgramUniform3iv glProgramUniform3iv;
    da_glProgramUniform3f glProgramUniform3f;
    da_glProgramUniform3fv glProgramUniform3fv;
    da_glProgramUniform3d glProgramUniform3d;
    da_glProgramUniform3dv glProgramUniform3dv;
    da_glProgramUniform3ui glProgramUniform3ui;
    da_glProgramUniform3uiv glProgramUniform3uiv;
    da_glProgramUniform4i glProgramUniform4i;
    da_glProgramUniform4iv glProgramUniform4iv;
    da_glProgramUniform4f glProgramUniform4f;
    da_glProgramUniform4fv glProgramUniform4fv;
    da_glProgramUniform4d glProgramUniform4d;
    da_glProgramUniform4dv glProgramUniform4dv;
    da_glProgramUniform4ui glProgramUniform4ui;
    da_glProgramUniform4uiv glProgramUniform4uiv;
    da_glProgramUniformMatrix2fv glProgramUniformMatrix2fv;
    da_glProgramUniformMatrix3fv glProgramUniformMatrix3fv;
    da_glProgramUniformMatrix4fv glProgramUniformMatrix4fv;
    da_glProgramUniformMatrix2dv glProgramUniformMatrix2dv;
    da_glProgramUniformMatrix3dv glProgramUniformMatrix3dv;
    da_glProgramUniformMatrix4dv glProgramUniformMatrix4dv;
    da_glProgramUniformMatrix2x3fv glProgramUniformMatrix2x3fv;
    da_glProgramUniformMatrix3x2fv glProgramUniformMatrix3x2fv;
    da_glProgramUniformMatrix2x4fv glProgramUniformMatrix2x4fv;
    da_glProgramUniformMatrix4x2fv glProgramUniformMatrix4x2fv;
    da_glProgramUniformMatrix3x4fv glProgramUniformMatrix3x4fv;
    da_glProgramUniformMatrix4x3fv glProgramUniformMatrix4x3fv;
    da_glProgramUniformMatrix2x3dv glProgramUniformMatrix2x3dv;
    da_glProgramUniformMatrix3x2dv glProgramUniformMatrix3x2dv;
    da_glProgramUniformMatrix2x4dv glProgramUniformMatrix2x4dv;
    da_glProgramUniformMatrix4x2dv glProgramUniformMatrix4x2dv;
    da_glProgramUniformMatrix3x4dv glProgramUniformMatrix3x4dv;
    da_glProgramUniformMatrix4x3dv glProgramUniformMatrix4x3dv;
    da_glValidateProgramPipeline glValidateProgramPipeline;
    da_glGetProgramPipelineInfoLog glGetProgramPipelineInfoLog;
}

private __gshared bool _ARB_separate_shader_objects;
bool ARB_separate_shader_objects() @property { return _ARB_separate_shader_objects; }
private void load_ARB_separate_shader_objects()
{
    try
    {
        bindGLFunc(cast(void**)&glUseProgramStages, "glUseProgramStages");
        bindGLFunc(cast(void**)&glActiveShaderProgram, "glActiveShaderProgram");
        bindGLFunc(cast(void**)&glCreateShaderProgramv, "glCreateShaderProgramv");
        bindGLFunc(cast(void**)&glBindProgramPipeline, "glBindProgramPipeline");
        bindGLFunc(cast(void**)&glDeleteProgramPipelines, "glDeleteProgramPipelines");
        bindGLFunc(cast(void**)&glGenProgramPipelines, "glGenProgramPipelines");
        bindGLFunc(cast(void**)&glIsProgramPipeline, "glIsProgramPipeline");
        bindGLFunc(cast(void**)&glGetProgramPipelineiv, "glGetProgramPipelineiv");
        bindGLFunc(cast(void**)&glProgramUniform1i, "glProgramUniform1i");
        bindGLFunc(cast(void**)&glProgramUniform1iv, "glProgramUniform1iv");
        bindGLFunc(cast(void**)&glProgramUniform1f, "glProgramUniform1f");
        bindGLFunc(cast(void**)&glProgramUniform1fv, "glProgramUniform1fv");
        bindGLFunc(cast(void**)&glProgramUniform1d, "glProgramUniform1d");
        bindGLFunc(cast(void**)&glProgramUniform1dv, "glProgramUniform1dv");
        bindGLFunc(cast(void**)&glProgramUniform1ui, "glProgramUniform1ui");
        bindGLFunc(cast(void**)&glProgramUniform1uiv, "glProgramUniform1uiv");
        bindGLFunc(cast(void**)&glProgramUniform2i, "glProgramUniform2i");
        bindGLFunc(cast(void**)&glProgramUniform2iv, "glProgramUniform2iv");
        bindGLFunc(cast(void**)&glProgramUniform2f, "glProgramUniform2f");
        bindGLFunc(cast(void**)&glProgramUniform2fv, "glProgramUniform2fv");
        bindGLFunc(cast(void**)&glProgramUniform2d, "glProgramUniform2d");
        bindGLFunc(cast(void**)&glProgramUniform2dv, "glProgramUniform2dv");
        bindGLFunc(cast(void**)&glProgramUniform2ui, "glProgramUniform2ui");
        bindGLFunc(cast(void**)&glProgramUniform2uiv, "glProgramUniform2uiv");
        bindGLFunc(cast(void**)&glProgramUniform3i, "glProgramUniform3i");
        bindGLFunc(cast(void**)&glProgramUniform3iv, "glProgramUniform3iv");
        bindGLFunc(cast(void**)&glProgramUniform3f, "glProgramUniform3f");
        bindGLFunc(cast(void**)&glProgramUniform3fv, "glProgramUniform3fv");
        bindGLFunc(cast(void**)&glProgramUniform3d, "glProgramUniform3d");
        bindGLFunc(cast(void**)&glProgramUniform3dv, "glProgramUniform3dv");
        bindGLFunc(cast(void**)&glProgramUniform3ui, "glProgramUniform3ui");
        bindGLFunc(cast(void**)&glProgramUniform3uiv, "glProgramUniform3uiv");
        bindGLFunc(cast(void**)&glProgramUniform4i, "glProgramUniform4i");
        bindGLFunc(cast(void**)&glProgramUniform4iv, "glProgramUniform4iv");
        bindGLFunc(cast(void**)&glProgramUniform4f, "glProgramUniform4f");
        bindGLFunc(cast(void**)&glProgramUniform4fv, "glProgramUniform4fv");
        bindGLFunc(cast(void**)&glProgramUniform4d, "glProgramUniform4d");
        bindGLFunc(cast(void**)&glProgramUniform4dv, "glProgramUniform4dv");
        bindGLFunc(cast(void**)&glProgramUniform4ui, "glProgramUniform4ui");
        bindGLFunc(cast(void**)&glProgramUniform4uiv, "glProgramUniform4uiv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix2fv, "glProgramUniformMatrix2fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix3fv, "glProgramUniformMatrix3fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix4fv, "glProgramUniformMatrix4fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix2dv, "glProgramUniformMatrix2dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix3dv, "glProgramUniformMatrix3dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix4dv, "glProgramUniformMatrix4dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix2x3fv, "glProgramUniformMatrix2x3fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix3x2fv, "glProgramUniformMatrix3x2fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix2x4fv, "glProgramUniformMatrix2x4fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix4x2fv, "glProgramUniformMatrix4x2fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix3x4fv, "glProgramUniformMatrix3x4fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix4x3fv, "glProgramUniformMatrix4x3fv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix2x3dv, "glProgramUniformMatrix2x3dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix3x2dv, "glProgramUniformMatrix3x2dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix2x4dv, "glProgramUniformMatrix2x4dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix4x2dv, "glProgramUniformMatrix4x2dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix3x4dv, "glProgramUniformMatrix3x4dv");
        bindGLFunc(cast(void**)&glProgramUniformMatrix4x3dv, "glProgramUniformMatrix4x3dv");
        bindGLFunc(cast(void**)&glValidateProgramPipeline, "glValidateProgramPipeline");
        bindGLFunc(cast(void**)&glGetProgramPipelineInfoLog, "glGetProgramPipelineInfoLog");
        _ARB_separate_shader_objects = true;
    }
    catch(Exception e)
    {
        _ARB_separate_shader_objects = false;
    }
}

// ARB_vertex_attrib_64bit
extern(System)
{
    alias nothrow void function(GLuint, GLdouble) da_glVertexAttribL1d;
    alias nothrow void function(GLuint, GLdouble, GLdouble) da_glVertexAttribL2d;
    alias nothrow void function(GLuint, GLdouble, GLdouble, GLdouble) da_glVertexAttribL3d;
    alias nothrow void function(GLuint, GLdouble, GLdouble, GLdouble, GLdouble) da_glVertexAttribL4d;
    alias nothrow void function(GLuint, const(GLdouble)*) da_glVertexAttribL1dv;
    alias nothrow void function(GLuint, const(GLdouble)*) da_glVertexAttribL2dv;
    alias nothrow void function(GLuint, const(GLdouble)*) da_glVertexAttribL3dv;
    alias nothrow void function(GLuint, const(GLdouble)*) da_glVertexAttribL4dv;
    alias nothrow void function(GLuint, GLint, GLenum, GLsizei, const(GLvoid)*) da_glVertexAttribLPointer;
    alias nothrow void function(GLuint, GLenum, GLdouble*) da_glGetVertexAttribLdv;
}

__gshared
{
    da_glVertexAttribL1d glVertexAttribL1d;
    da_glVertexAttribL2d glVertexAttribL2d;
    da_glVertexAttribL3d glVertexAttribL3d;
    da_glVertexAttribL4d glVertexAttribL4d;
    da_glVertexAttribL1dv glVertexAttribL1dv;
    da_glVertexAttribL2dv glVertexAttribL2dv;
    da_glVertexAttribL3dv glVertexAttribL3dv;
    da_glVertexAttribL4dv glVertexAttribL4dv;
    da_glVertexAttribLPointer glVertexAttribLPointer;
    da_glGetVertexAttribLdv glGetVertexAttribLdv;
}

private __gshared bool _ARB_vertex_attrib_64bit;
bool ARB_vertex_attrib_64bit() @property { return _ARB_vertex_attrib_64bit; }
private void load_ARB_vertex_attrib_64bit()
{
    try
    {
        bindGLFunc(cast(void**)&glVertexAttribL1d, "glVertexAttribL1d");
        bindGLFunc(cast(void**)&glVertexAttribL2d, "glVertexAttribL2d");
        bindGLFunc(cast(void**)&glVertexAttribL3d, "glVertexAttribL3d");
        bindGLFunc(cast(void**)&glVertexAttribL4d, "glVertexAttribL4d");
        bindGLFunc(cast(void**)&glVertexAttribL1dv, "glVertexAttribL1dv");
        bindGLFunc(cast(void**)&glVertexAttribL2dv, "glVertexAttribL2dv");
        bindGLFunc(cast(void**)&glVertexAttribL3dv, "glVertexAttribL3dv");
        bindGLFunc(cast(void**)&glVertexAttribL4dv, "glVertexAttribL4dv");
        bindGLFunc(cast(void**)&glVertexAttribLPointer, "glVertexAttribLPointer");
        bindGLFunc(cast(void**)&glGetVertexAttribLdv, "glGetVertexAttribLdv");
        _ARB_vertex_attrib_64bit = true;
    }
    catch(Exception e)
    {
        _ARB_vertex_attrib_64bit = false;
    }
}

// ARB_viewport_array
extern(System)
{
    alias nothrow void function(GLuint, GLsizei, const(GLfloat)*) da_glViewportArrayv;
    alias nothrow void function(GLuint, GLfloat, GLfloat, GLfloat, GLfloat) da_glViewportIndexedf;
    alias nothrow void function(GLuint, const(GLfloat)*) da_glViewportIndexedfv;
    alias nothrow void function(GLuint, GLsizei, const(GLint)*) da_glScissorArrayv;
    alias nothrow void function(GLuint, GLint, GLint, GLsizei, GLsizei) da_glScissorIndexed;
    alias nothrow void function(GLuint, const(GLint)*) da_glScissorIndexedv;
    alias nothrow void function(GLuint, GLsizei, const(GLclampd)*) da_glDepthRangeArrayv;
    alias nothrow void function(GLuint, GLclampd, GLclampd) da_glDepthRangeIndexed;
    alias nothrow void function(GLenum, GLuint, GLfloat*) da_glGetFloati_v;
    alias nothrow void function(GLenum, GLuint, GLdouble*) da_glGetDoublei_v;
}

__gshared
{
    da_glViewportArrayv glViewportArrayv;
    da_glViewportIndexedf glViewportIndexedf;
    da_glViewportIndexedfv glViewportIndexedfv;
    da_glScissorArrayv glScissorArrayv;
    da_glScissorIndexed glScissorIndexed;
    da_glScissorIndexedv glScissorIndexedv;
    da_glDepthRangeArrayv glDepthRangeArrayv;
    da_glDepthRangeIndexed glDepthRangeIndexed;
    da_glGetFloati_v glGetFloati_v;
    da_glGetDoublei_v glGetDoublei_v;
}

private __gshared bool _ARB_viewport_array;
bool ARB_viewport_array() @property { return _ARB_viewport_array; }
private void load_ARB_viewport_array()
{
    try
    {
        bindGLFunc(cast(void**)&glViewportArrayv, "glViewportArrayv");
        bindGLFunc(cast(void**)&glViewportIndexedf, "glViewportIndexedf");
        bindGLFunc(cast(void**)&glViewportIndexedfv, "glViewportIndexedfv");
        bindGLFunc(cast(void**)&glScissorArrayv, "glScissorArrayv");
        bindGLFunc(cast(void**)&glScissorIndexed, "glScissorIndexed");
        bindGLFunc(cast(void**)&glScissorIndexedv, "glScissorIndexedv");
        bindGLFunc(cast(void**)&glDepthRangeArrayv, "glDepthRangeArrayv");
        bindGLFunc(cast(void**)&glDepthRangeIndexed, "glDepthRangeIndexed");
        bindGLFunc(cast(void**)&glGetFloati_v, "glGetFloati_v");
        bindGLFunc(cast(void**)&glGetDoublei_v, "glGetDoublei_v");
        _ARB_viewport_array = true;
    }
    catch(Exception e)
    {
        _ARB_viewport_array = false;
    }
}

// ARB_cl_event
extern(System) alias nothrow GLsync function(_cl_context*, _cl_event*, GLbitfield) da_glCreateSyncFromCLeventARB;
__gshared da_glCreateSyncFromCLeventARB glCreateSyncFromCLeventARB;

private __gshared bool _ARB_cl_event;
bool ARB_cl_event() @property { return _ARB_cl_event; }
private void load_ARB_cl_event()
{
    try
    {
        bindGLFunc(cast(void**)&glCreateSyncFromCLeventARB, "glCreateSyncFromCLeventARB");
        _ARB_cl_event = true;
    }
    catch(Exception e)
    {
        _ARB_cl_event = false;
    }
}

// ARB_debug_output
extern(System)
{
    alias nothrow void function(GLenum, GLenum, GLenum, GLsizei, const(GLuint)*, GLboolean) da_glDebugMessageControlARB;
    alias nothrow void function(GLenum, GLenum, GLuint, GLenum, GLsizei, const(GLchar)*) da_glDebugMessageInsertARB;
    alias nothrow void function(GLDEBUGPROCARB, const(GLvoid)*) da_glDebugMessageCallbackARB;
    alias nothrow void function(GLuint, GLsizei, GLenum*, GLenum*, GLuint*, GLenum*, GLsizei*, GLchar*) da_glGetDebugMessageLogARB;
}

__gshared
{
    da_glDebugMessageControlARB glDebugMessageControlARB;
    da_glDebugMessageInsertARB glDebugMessageInsertARB;
    da_glDebugMessageCallbackARB glDebugMessageCallbackARB;
    da_glGetDebugMessageLogARB glGetDebugMessageLogARB;
}

private __gshared bool _ARB_debug_output;
bool ARB_debug_output() @property { return _ARB_debug_output; }
private void load_ARB_debug_output()
{
    try
    {
        bindGLFunc(cast(void**)&glDebugMessageControlARB, "glDebugMessageControlARB");
        bindGLFunc(cast(void**)&glDebugMessageInsertARB, "glDebugMessageInsertARB");
        bindGLFunc(cast(void**)&glDebugMessageCallbackARB, "glDebugMessageCallbackARB");
        bindGLFunc(cast(void**)&glGetDebugMessageLogARB, "glGetDebugMessageLogARB");
        _ARB_debug_output = true;
    }
    catch(Exception e)
    {
        _ARB_debug_output = false;
    }
}

// ARB_robustness
extern(System)
{
    alias nothrow GLenum function() da_glGetGraphicsResetStatusARB;
    alias nothrow void function(GLenum, GLenum, GLsizei, GLdouble*) da_glGetnMapdvARB;
    alias nothrow void function(GLenum, GLenum, GLsizei, GLfloat*) da_glGetnMapfvARB;
    alias nothrow void function(GLenum, GLenum, GLsizei, GLint*) da_glGetnMapivARB;
    alias nothrow void function(GLenum, GLsizei, GLfloat*) da_glGetnPixelMapfvARB;
    alias nothrow void function(GLenum, GLsizei, GLuint*) da_glGetnPixelMapuivARB;
    alias nothrow void function(GLenum, GLsizei, GLushort*) da_glGetnPixelMapusvARB;
    alias nothrow void function(GLsizei, GLubyte*) da_glGetnPolygonStippleARB;
    alias nothrow void function(GLenum, GLenum, GLenum, GLsizei, GLvoid*) da_glGetnColorTableARB;
    alias nothrow void function(GLenum, GLenum, GLenum, GLsizei, GLvoid*) da_glGetnConvolutionFilterARB;
    alias nothrow void function(GLenum, GLenum, GLenum, GLsizei, GLvoid*, GLsizei, GLvoid*, GLvoid*) da_glGetnSeparableFilterARB;
    alias nothrow void function(GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid*) da_glGetnHistogramARB;
    alias nothrow void function(GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid*) da_glGetnMinmaxARB;
    alias nothrow void function(GLenum, GLint, GLenum, GLenum, GLsizei, GLvoid*) da_glGetnTexImageARB;
    alias nothrow void function(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, GLvoid*) da_glReadnPixelsARB;
    alias nothrow void function(GLenum, GLint, GLsizei, GLvoid*) da_glGetnCompressedTexImageARB;
    alias nothrow void function(GLuint, GLint, GLsizei, GLfloat*) da_glGetnUniformfvARB;
    alias nothrow void function(GLuint, GLint, GLsizei, GLint*) da_glGetnUniformivARB;
    alias nothrow void function(GLuint, GLint, GLsizei, GLuint*) da_glGetnUniformuivARB;
    alias nothrow void function(GLuint, GLint, GLsizei, GLdouble*) da_glGetnUniformdvARB;
}

__gshared
{
    da_glGetGraphicsResetStatusARB glGetGraphicsResetStatusARB;
    da_glGetnMapdvARB glGetnMapdvARB;
    da_glGetnMapfvARB glGetnMapfvARB;
    da_glGetnMapivARB glGetnMapivARB;
    da_glGetnPixelMapfvARB glGetnPixelMapfvARB;
    da_glGetnPixelMapuivARB glGetnPixelMapuivARB;
    da_glGetnPixelMapusvARB glGetnPixelMapusvARB;
    da_glGetnPolygonStippleARB glGetnPolygonStippleARB;
    da_glGetnColorTableARB glGetnColorTableARB;
    da_glGetnConvolutionFilterARB glGetnConvolutionFilterARB;
    da_glGetnSeparableFilterARB glGetnSeparableFilterARB;
    da_glGetnHistogramARB glGetnHistogramARB;
    da_glGetnMinmaxARB glGetnMinmaxARB;
    da_glGetnTexImageARB glGetnTexImageARB;
    da_glReadnPixelsARB glReadnPixelsARB;
    da_glGetnCompressedTexImageARB glGetnCompressedTexImageARB;
    da_glGetnUniformfvARB glGetnUniformfvARB;
    da_glGetnUniformivARB glGetnUniformivARB;
    da_glGetnUniformuivARB glGetnUniformuivARB;
    da_glGetnUniformdvARB glGetnUniformdvARB;
}

private __gshared bool _ARB_robustness;
bool ARB_robustness() @property { return _ARB_robustness; }
private void load_ARB_robustness()
{
    try
    {
        bindGLFunc(cast(void**)&glGetGraphicsResetStatusARB, "glGetGraphicsResetStatusARB");
        bindGLFunc(cast(void**)&glGetnMapdvARB, "glGetnMapdvARB");
        bindGLFunc(cast(void**)&glGetnMapfvARB, "glGetnMapfvARB");
        bindGLFunc(cast(void**)&glGetnMapivARB, "glGetnMapivARB");
        bindGLFunc(cast(void**)&glGetnPixelMapfvARB, "glGetnPixelMapfvARB");
        bindGLFunc(cast(void**)&glGetnPixelMapuivARB, "glGetnPixelMapuivARB");
        bindGLFunc(cast(void**)&glGetnPixelMapusvARB, "glGetnPixelMapusvARB");
        bindGLFunc(cast(void**)&glGetnPolygonStippleARB, "glGetnPolygonStippleARB");
        bindGLFunc(cast(void**)&glGetnColorTableARB, "glGetnColorTableARB");
        bindGLFunc(cast(void**)&glGetnConvolutionFilterARB, "glGetnConvolutionFilterARB");
        bindGLFunc(cast(void**)&glGetnSeparableFilterARB, "glGetnSeparableFilterARB");
        bindGLFunc(cast(void**)&glGetnHistogramARB, "glGetnHistogramARB");
        bindGLFunc(cast(void**)&glGetnMinmaxARB, "glGetnMinmaxARB");
        bindGLFunc(cast(void**)&glGetnTexImageARB, "glGetnTexImageARB");
        bindGLFunc(cast(void**)&glReadnPixelsARB, "glReadnPixelsARB");
        bindGLFunc(cast(void**)&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB");
        bindGLFunc(cast(void**)&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB");
        bindGLFunc(cast(void**)&glGetnUniformfvARB, "glGetnUniformfvARB");
        bindGLFunc(cast(void**)&glGetnUniformivARB, "glGetnUniformivARB");
        bindGLFunc(cast(void**)&glGetnUniformuivARB, "glGetnUniformuivARB");
        bindGLFunc(cast(void**)&glGetnUniformdvARB, "glGetnUniformdvARB");
        _ARB_robustness = true;
    }
    catch(Exception e)
    {
        _ARB_robustness = false;
    }
}

// ARB_base_instance
extern(System)
{
    alias nothrow void function(GLenum, GLint, GLsizei, GLsizei, GLuint) da_glDrawArraysInstancedBaseInstance;
    alias nothrow void function(GLenum, GLsizei, GLenum, const(void)*, GLsizei, GLuint) da_glDrawElementsInstancedBaseInstance;
    alias nothrow void function(GLenum, GLsizei, GLenum, const(void)*, GLsizei, GLint, GLuint) da_glDrawElementsInstancedBaseVertexBaseInstance;
}

__gshared
{
    da_glDrawArraysInstancedBaseInstance glDrawArraysInstancedBaseInstance;
    da_glDrawElementsInstancedBaseInstance glDrawElementsInstancedBaseInstance;
    da_glDrawElementsInstancedBaseVertexBaseInstance glDrawElementsInstancedBaseVertexBaseInstance;
}

private __gshared bool _ARB_base_instance;
bool ARB_base_instance() @property { return _ARB_base_instance; }
private void load_ARB_base_instance()
{
    try
    {
        bindGLFunc(cast(void**)&glDrawArraysInstancedBaseInstance, "glDrawArraysInstancedBaseInstance");
        bindGLFunc(cast(void**)&glDrawElementsInstancedBaseInstance, "glDrawElementsInstancedBaseInstance");
        bindGLFunc(cast(void**)&glDrawElementsInstancedBaseVertexBaseInstance, "glDrawElementsInstancedBaseVertexBaseInstance");
        _ARB_base_instance = true;
    }
    catch(Exception e)
    {
        _ARB_base_instance = false;
    }
}

// ARB_transform_feedback_instanced
extern(System) alias nothrow void function(GLenum, GLuint, GLsizei) da_glDrawTransformFeedbackInstanced;
extern(System) alias nothrow void function(GLenum, GLuint, GLuint, GLsizei) da_glDrawTransformFeedbackStreamInstanced;
__gshared da_glDrawTransformFeedbackInstanced glDrawTransformFeedbackInstanced;
__gshared da_glDrawTransformFeedbackStreamInstanced glDrawTransformFeedbackStreamInstanced;

private __gshared bool _ARB_transform_feedback_instanced;
bool ARB_transform_feedback_instanced() @property { return _ARB_transform_feedback_instanced; }
private void load_ARB_transform_feedback_instanced()
{
    try
    {
        bindGLFunc(cast(void**)&glDrawTransformFeedbackInstanced, "glDrawTransformFeedbackInstanced");
        bindGLFunc(cast(void**)&glDrawTransformFeedbackStreamInstanced, "glDrawTransformFeedbackStreamInstanced");
        _ARB_transform_feedback_instanced = true;
    }
    catch(Exception e)
    {
        _ARB_transform_feedback_instanced = false;
    }
}

// ARB_internalformat_query
extern(System) alias nothrow void function(GLenum, GLenum, GLenum, GLsizei, GLint*) da_glGetInternalformativ;
__gshared da_glGetInternalformativ glGetInternalformativ;

private __gshared bool _ARB_internalformat_query;
bool ARB_internalformat_query() @property { return _ARB_internalformat_query; }
private void load_ARB_internalformat_query()
{
    try
    {
        bindGLFunc(cast(void**)&glGetInternalformativ, "glGetInternalformativ");
        _ARB_internalformat_query = true;
    }
    catch(Exception e)
    {
        _ARB_internalformat_query = false;
    }
}

// ARB_shader_atomic_counters
extern(System) alias nothrow void function(GLuint, GLuint, GLenum, GLint*) da_glGetActiveAtomicCounterBufferiv;
__gshared da_glGetActiveAtomicCounterBufferiv glGetActiveAtomicCounterBufferiv;

private __gshared bool _ARB_shader_atomic_counters;
bool ARB_shader_atomic_counters() @property { return _ARB_shader_atomic_counters; }
private void load_ARB_shader_atomic_counters()
{
    try
    {
        bindGLFunc(cast(void**)&glGetActiveAtomicCounterBufferiv, "glGetActiveAtomicCounterBufferiv");
        _ARB_shader_atomic_counters = true;
    }
    catch(Exception e)
    {
        _ARB_shader_atomic_counters = false;
    }
}

// ARB_shader_image_load_store
extern(System) alias nothrow void function(GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum) da_glBindImageTexture;
extern(System) alias nothrow void function(GLbitfield) da_glMemoryBarrier;
__gshared da_glBindImageTexture glBindImageTexture;
__gshared da_glMemoryBarrier glMemoryBarrier;

private __gshared bool _ARB_shader_image_load_store;
bool ARB_shader_image_load_store() @property { return _ARB_shader_image_load_store; }
private void load_ARB_shader_image_load_store()
{
    try
    {
        bindGLFunc(cast(void**)&glBindImageTexture, "glBindImageTexture");
        bindGLFunc(cast(void**)&glMemoryBarrier, "glMemoryBarrier");
        _ARB_shader_image_load_store = true;
    }
    catch(Exception e)
    {
        _ARB_shader_image_load_store = false;
    }
}

// ARB_texture_storage
extern(System)
{
    alias nothrow void function(GLenum, GLsizei, GLenum, GLsizei) da_glTexStorage1D;
    alias nothrow void function(GLenum, GLsizei, GLenum, GLsizei, GLsizei) da_glTexStorage2D;
    alias nothrow void function(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei) da_glTexStorage3D;
    alias nothrow void function(GLuint, GLenum, GLsizei, GLenum, GLsizei) da_glTextureStorage1DEXT;
    alias nothrow void function(GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei) da_glTextureStorage2DEXT;
    alias nothrow void function(GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei) da_glTextureStorage3DEXT;
}

__gshared
{
    da_glTexStorage1D glTexStorage1D;
    da_glTexStorage2D glTexStorage2D;
    da_glTexStorage3D glTexStorage3D;
    da_glTextureStorage1DEXT glTextureStorage1DEXT;
    da_glTextureStorage2DEXT glTextureStorage2DEXT;
    da_glTextureStorage3DEXT glTextureStorage3DEXT;
}

private __gshared bool _ARB_texture_storage;
bool ARB_texture_storage() @property { return _ARB_texture_storage; }
private void load_ARB_texture_storage()
{
    try
    {
        bindGLFunc(cast(void**)&glTexStorage1D, "glTexStorage1D");
        bindGLFunc(cast(void**)&glTexStorage2D, "glTexStorage2D");
        bindGLFunc(cast(void**)&glTexStorage3D, "glTexStorage3D");
        bindGLFunc(cast(void**)&glTextureStorage1DEXT, "glTextureStorage1DEXT");
        bindGLFunc(cast(void**)&glTextureStorage2DEXT, "glTextureStorage2DEXT");
        bindGLFunc(cast(void**)&glTextureStorage3DEXT, "glTextureStorage3DEXT");
        _ARB_texture_storage = true;
    }
    catch(Exception e)
    {
        _ARB_texture_storage = false;
    }
}

package void loadARB(GLVersion glversion)
{
    if(glversion >= GLVersion.GL30)
    {
        _ARB_framebuffer_object = true;
        _ARB_map_buffer_range = true;
        _ARB_vertex_array_object = true;
    }
    else
    {
        _ARB_framebuffer_object = isExtSupported(glversion, "GL_ARB_framebuffer_object");
        if(_ARB_framebuffer_object) load_ARB_framebuffer_object();
        _ARB_map_buffer_range = isExtSupported(glversion, "GL_ARB_map_buffer_range");
        if(_ARB_map_buffer_range) load_ARB_map_buffer_range();
        _ARB_vertex_array_object = isExtSupported(glversion, "GL_ARB_vertex_array_object");
        if(_ARB_vertex_array_object) load_ARB_vertex_array_object();
    }

    if(glversion >= GLVersion.GL31)
    {
        _ARB_copy_buffer = true;
        _ARB_uniform_buffer_object = true;
    }
    else
    {
        _ARB_copy_buffer = isExtSupported(glversion, "GL_ARB_copy_buffer");
        if(_ARB_copy_buffer) load_ARB_copy_buffer();
        _ARB_uniform_buffer_object = isExtSupported(glversion, "GL_ARB_uniform_buffer_object");
        if(_ARB_uniform_buffer_object) load_ARB_uniform_buffer_object();
    }

    if(glversion >= GLVersion.GL32)
    {
        _ARB_draw_elements_base_vertex = true;
        _ARB_provoking_vertex = true;
        _ARB_sync = true;
        _ARB_texture_multisample = true;
    }
    else
    {
        _ARB_draw_elements_base_vertex = isExtSupported(glversion, "GL_ARB_draw_elements_base_vertex");
        if(_ARB_draw_elements_base_vertex) load_ARB_draw_elements_base_vertex();
        _ARB_provoking_vertex = isExtSupported(glversion, "GL_ARB_provoking_vertex");
        if(_ARB_provoking_vertex) load_ARB_provoking_vertex();
        _ARB_sync = isExtSupported(glversion, "GL_ARB_sync");
        if(_ARB_sync) load_ARB_sync();
        _ARB_texture_multisample = isExtSupported(glversion, "GL_ARB_texture_multisample");
        if(_ARB_texture_multisample) load_ARB_texture_multisample();
    }

    if(glversion >= GLVersion.GL33)
    {
        _ARB_blend_func_extended = true;
        _ARB_sampler_objects = true;
        _ARB_explicit_attrib_location = true;
        _ARB_occlusion_query2 = true;
        _ARB_shader_bit_encoding = true;
        _ARB_texture_rgb10_a2ui = true;
        _ARB_texture_swizzle = true;
        _ARB_timer_query = true;
        _ARB_vertex_type_2_10_10_10_rev = true;
    }
    else
    {
        _ARB_blend_func_extended = isExtSupported(glversion, "GL_ARB_blend_func_extended");
        if(_ARB_blend_func_extended) load_ARB_blend_func_extended();
        _ARB_sampler_objects = isExtSupported(glversion, "GL_ARB_sampler_objects");
        if(_ARB_sampler_objects) load_ARB_sampler_objects();
        _ARB_explicit_attrib_location = isExtSupported(glversion, "GL_ARB_explicit_attrib_location");
        _ARB_occlusion_query2 = isExtSupported(glversion, "GL_ARB_occlusion_query2");
        _ARB_shader_bit_encoding = isExtSupported(glversion, "GL_ARB_shader_bit_encoding");
        _ARB_texture_rgb10_a2ui = isExtSupported(glversion, "GL_ARB_texture_rgb10_a2ui");
        _ARB_texture_swizzle = isExtSupported(glversion, "GL_ARB_texture_swizzle");
        _ARB_timer_query = isExtSupported(glversion, "GL_ARB_timer_query");
        if(_ARB_timer_query) load_ARB_timer_query();
        _ARB_vertex_type_2_10_10_10_rev = isExtSupported(glversion, "GL_ARB_vertex_type_2_10_10_10_rev");
        if(_ARB_vertex_type_2_10_10_10_rev) load_ARB_vertex_type_2_10_10_10_rev();
    }

    if(glversion >= GLVersion.GL40)
    {
        _ARB_texture_query_lod = true;
        _ARB_draw_indirect = true;
        _ARB_gpu_shader5 = true;
        _ARB_gpu_shader_fp64 = true;
        _ARB_shader_subroutine = true;
        _ARB_tessellation_shader = true;
        _ARB_texture_buffer_object_rgb32 = true;
        _ARB_texture_cube_map_array = true;
        _ARB_texture_gather = true;
        _ARB_transform_feedback2 = true;
        _ARB_transform_feedback3 = true;
    }
    else
    {
        _ARB_texture_query_lod = isExtSupported(glversion, "GL_ARB_texture_query_lod");
        _ARB_draw_indirect = isExtSupported(glversion, "GL_ARB_draw_indirect");
        if(_ARB_draw_indirect) load_ARB_draw_indirect();
        _ARB_gpu_shader5 = isExtSupported(glversion, "GL_ARB_gpu_shader5");
        _ARB_gpu_shader_fp64 = isExtSupported(glversion, "GL_ARB_gpu_shader_fp64");
        if(_ARB_gpu_shader_fp64) load_ARB_gpu_shader_fp64();
        _ARB_shader_subroutine = isExtSupported(glversion, "GL_ARB_shader_subroutine");
        if(_ARB_shader_subroutine) load_ARB_shader_subroutine();
        _ARB_tessellation_shader = isExtSupported(glversion, "GL_ARB_tessellation_shader");
        if(_ARB_tessellation_shader) load_ARB_tessellation_shader();
        _ARB_texture_buffer_object_rgb32 = isExtSupported(glversion, "GL_ARB_texture_buffer_object_rgb32");
        _ARB_texture_cube_map_array = isExtSupported(glversion, "GL_ARB_texture_cube_map_array");
        _ARB_texture_gather = isExtSupported(glversion, "GL_ARB_texture_gather");
        _ARB_transform_feedback2 = isExtSupported(glversion, "GL_ARB_transform_feedback2");
        if(_ARB_transform_feedback2) load_ARB_transform_feedback2();
        _ARB_transform_feedback3 = isExtSupported(glversion, "GL_ARB_transform_feedback3");
        if(_ARB_transform_feedback3) load_ARB_transform_feedback3();
    }

    if(glversion >= GLVersion.GL41)
    {
        _ARB_ES2_compatibility = true;
        _ARB_get_program_binary = true;
        _ARB_separate_shader_objects = true;
        _ARB_shader_precision = true;
        _ARB_vertex_attrib_64bit = true;
        _ARB_viewport_array = true;
    }
    else
    {
        _ARB_ES2_compatibility = isExtSupported(glversion, "GL_ARB_ES2_compatibility");
        if(_ARB_ES2_compatibility) load_ARB_ES2_compatibility();
        _ARB_get_program_binary = isExtSupported(glversion, "GL_ARB_get_program_binary");
        if(_ARB_get_program_binary) load_ARB_get_program_binary();
        _ARB_separate_shader_objects = isExtSupported(glversion, "GL_ARB_separate_shader_objects");
        if(_ARB_separate_shader_objects) load_ARB_separate_shader_objects();
        _ARB_shader_precision = isExtSupported(glversion, "GL_ARB_shader_precision");
        _ARB_vertex_attrib_64bit = isExtSupported(glversion, "GL_ARB_vertex_attrib_64bit");
        if(_ARB_vertex_attrib_64bit) load_ARB_vertex_attrib_64bit();
        _ARB_viewport_array = isExtSupported(glversion, "GL_ARB_viewport_array");
        if(_ARB_viewport_array) load_ARB_viewport_array();
    }

    if(glversion >= GLVersion.GL42)
    {
        _ARB_base_instance = true;
        _ARB_shading_language_420pack = true;
        _ARB_transform_feedback_instanced = true;
        _ARB_compressed_texture_pixel_storage = true;
        _ARB_conservative_depth = true;
        _ARB_internalformat_query = true;
        _ARB_map_buffer_alignment = true;
        _ARB_shader_atomic_counters = true;
        _ARB_shader_image_load_store = true;
        _ARB_shading_language_packing = true;
        _ARB_texture_storage = true;
    }
    else
    {
        _ARB_base_instance = isExtSupported(glversion, "GL_ARB_base_instance");
        if(_ARB_base_instance) load_ARB_base_instance();
        _ARB_shading_language_420pack = isExtSupported(glversion, "GL_ARB_shading_language_420pack");
        _ARB_transform_feedback_instanced = isExtSupported(glversion, "GL_ARB_transform_feedback_instanced");
        if(_ARB_transform_feedback_instanced) load_ARB_transform_feedback_instanced();
        _ARB_compressed_texture_pixel_storage = isExtSupported(glversion, "GL_ARB_compressed_texture_pixel_storage");
        _ARB_conservative_depth = isExtSupported(glversion, "GL_ARB_conservative_depth");
        _ARB_internalformat_query = isExtSupported(glversion, "GL_ARB_internalformat_query");
        if(_ARB_internalformat_query) load_ARB_internalformat_query();
        _ARB_map_buffer_alignment = isExtSupported(glversion, "GL_ARB_map_buffer_alignment");
        _ARB_shader_atomic_counters = isExtSupported(glversion, "GL_ARB_shader_atomic_counters");
        if(_ARB_shader_atomic_counters) load_ARB_shader_atomic_counters();
        _ARB_shader_image_load_store = isExtSupported(glversion, "GL_ARB_shader_image_load_store");
        if(_ARB_shader_image_load_store) load_ARB_shader_image_load_store();
        _ARB_shading_language_packing = isExtSupported(glversion, "GL_ARB_shading_language_packing");
        _ARB_texture_storage = isExtSupported(glversion, "GL_ARB_texture_storage");
        if(_ARB_texture_storage) load_ARB_texture_storage();
    }
}
